<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Generate Report - Navigate Reports Hub</title>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <!-- Version: 2025-09-18-12:14 - Header strip patch -->
  <style>
    /* Custom styles for table headers to ensure background colors are applied */
    .bg-blue-100 { background-color: #dbeafe !important; }
    .bg-blue-200 { background-color: #bfdbfe !important; }
    .bg-purple-100 { background-color: #f3e8ff !important; }
    .bg-yellow-100 { background-color: #fef3c7 !important; }
    .bg-green-200 { background-color: #bbf7d0 !important; }
    .bg-pink-100 { background-color: #fce7f3 !important; }
    .bg-indigo-100 { background-color: #e0e7ff !important; }
    .bg-gray-100 { background-color: #f3f4f6 !important; }
    .bg-amber-100 { background-color: #fef3c7 !important; }
    .bg-teal-100 { background-color: #ccfbf1 !important; }
    .bg-cyan-100 { background-color: #e0f7fa !important; }
    
    /* Change indicator colors */
    .bg-green-100 { background-color: #dcfce7 !important; }
    .bg-red-100 { background-color: #fee2e2 !important; }
    .bg-orange-100 { background-color: #ffedd5 !important; }
    .text-green-600 { color: #16a34a !important; }
    .text-red-600 { color: #dc2626 !important; }
    .text-orange-600 { color: #ea580c !important; }
    .text-gray-600 { color: #4b5563 !important; }
    
    /* Mobile-specific styles */
    @media (max-width: 768px) {
      .mobile-card { margin-bottom: 1rem; }
      .mobile-button-group { display: flex; flex-direction: column; gap: 0.5rem; }
      .mobile-button-group button { width: 100%; }
      .mobile-form-grid { grid-template-columns: 1fr; }
      .mobile-actions { flex-direction: column; gap: 0.5rem; }
      .mobile-table-actions { display: flex; flex-direction: column; gap: 0.25rem; }
      .mobile-table-actions button { font-size: 0.75rem; padding: 0.25rem 0.5rem; }
    }
    
    /* Custom scrollbar */
    .custom-scrollbar::-webkit-scrollbar {
      width: 4px;
      height: 4px;
    }
    .custom-scrollbar::-webkit-scrollbar-track {
      background: #f1f1f1;
    }
    .custom-scrollbar::-webkit-scrollbar-thumb {
      background: #c1c1c1;
      border-radius: 2px;
    }
    .custom-scrollbar::-webkit-scrollbar-thumb:hover {
      background: #a8a8a8;
    }
    /* Thicker horizontal scrollbar for report preview */
    .custom-scrollbar-thick::-webkit-scrollbar:horizontal {
      height: 14px;
    }
    .custom-scrollbar-thick::-webkit-scrollbar-thumb {
      border-radius: 7px;
    }
    /* Firefox */
    #tableScrollContainer {
      scrollbar-width: auto;
      scrollbar-color: #c1c1c1 #f1f1f1;
    }

    /* Toggleable table cell borders */
    .borders-on {
      border-collapse: collapse;
      border: 1px solid #e5e7eb; /* outer border for clarity */
    }
    .borders-on th,
    .borders-on td {
      border: 1px solid #e5e7eb !important; /* gray-200 */
    }
    /* Ensure header section rows also get borders */
    .borders-on thead th { 
      border: 1px solid #e5e7eb !important; 
    }
    
    /* Touch-friendly buttons */
    .touch-button {
      min-height: 44px;
      min-width: 44px;
    }
  </style>
</head>
<body class="bg-gray-50 min-h-screen">
  <div class="max-w-7xl mx-auto py-4 sm:py-8 px-2 sm:px-4">
    <!-- Header -->
    <div class="flex justify-between items-center mb-4 sm:mb-8">
      <div class="flex items-center space-x-3">
        <a href="/" class="text-blue-600 hover:text-blue-800">
          <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"></path>
          </svg>
        </a>
        <h1 class="text-2xl sm:text-4xl font-bold text-blue-800">Generate New Report</h1>
      </div>
      <div class="flex items-center space-x-2 sm:space-x-4">
        <div class="text-right hidden sm:block">
          <div id="userInfo" class="hidden">
            <p class="text-sm text-gray-600">Welcome, <span id="userName" class="font-medium text-gray-900"></span></p>
            <p class="text-xs text-gray-500"><span id="userRole" class="capitalize"></span></p>
          </div>
        </div>
        <button id="logoutBtn" onclick="logout()" class="hidden bg-red-500 text-white px-3 sm:px-4 py-2 rounded hover:bg-red-600 transition-colors duration-200 font-medium shadow-sm touch-button text-sm sm:text-base">
          Logout
        </button>
      </div>
    </div>

    <!-- Simplified Report Generation -->
    <div class="bg-white rounded-lg shadow p-4 sm:p-6 mb-4 sm:mb-6">
      <h2 class="text-xl sm:text-2xl font-semibold text-gray-900 mb-4 sm:mb-6">Report Generation</h2>
      
      <!-- Step 1: File Upload -->
      <div class="mb-6">
        <div class="flex items-center mb-3">
          <span class="bg-blue-500 text-white rounded-full w-6 h-6 flex items-center justify-center text-sm font-medium mr-3">1</span>
          <h3 class="text-lg font-medium text-gray-900">Upload Your Files</h3>
        </div>
        <label class="block text-sm font-medium text-gray-700 mb-2">Choose Excel/CSV Files</label>
        <input id="fileInput" type="file" multiple class="mb-4 w-full" accept=".xlsx,.xls,.csv">
        <div id="selectedFilesList" class="mb-4"></div>
        <button id="processBtn" class="bg-blue-500 text-white px-6 py-3 rounded-lg hover:bg-blue-600 transition-colors duration-200 font-medium shadow-sm w-full sm:w-auto">
          üì§ Upload & Process Files
        </button>
      </div>
        
      <!-- Step 2: Configure Report (shown after upload) -->
      <div id="headerAssignmentSection" class="mb-6 hidden">
        <div class="flex items-center mb-3">
          <span class="bg-green-500 text-white rounded-full w-6 h-6 flex items-center justify-center text-sm font-medium mr-3">2</span>
          <h3 class="text-lg font-medium text-gray-900">Configure Your Report</h3>
        </div>
        <div class="bg-green-50 border border-green-200 rounded-lg p-4">
          <p class="text-sm text-green-700 mb-4">Your files have been processed. Click headers below to organize them into sections (optional).</p>

            <!-- File-level Assignment (preferred for template creation) -->
            <div class="mb-4" id="fileAssignmentSection">
              <h5 class="font-medium text-gray-800 mb-3">üìÅ Assign Headers by File (Recommended)</h5>
              <p class="text-xs text-gray-600 mb-2">Set a section and colour for each uploaded file. All headers from that file will use the selected section.</p>
              <div id="fileAssignments" class="space-y-2">
                <!-- File assignment rows injected here -->
              </div>
            </div>

            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 mb-4">
              <!-- Section Color Legend -->
              <div class="bg-white rounded-lg border border-gray-200 p-3">
                <h5 class="font-medium text-gray-800 mb-2">üìä Available Sections</h5>
                <div class="space-y-2 text-sm">
                  <div class="flex items-center gap-2">
                    <div class="w-4 h-4 bg-blue-200 rounded"></div>
                    <span>Placements</span>
                  </div>
                  <div class="flex items-center gap-2">
                    <div class="w-4 h-4 bg-purple-100 rounded"></div>
                    <span>Employer Engagement</span>
                  </div>
                  <div class="flex items-center gap-2">
                    <div class="w-4 h-4 bg-teal-100 rounded"></div>
                    <span>Enrichment Activities</span>
                  </div>
                  <div class="flex items-center gap-2">
                    <div class="w-4 h-4 bg-green-200 rounded"></div>
                    <span>Assessments</span>
                  </div>
                  <div class="flex items-center gap-2">
                    <div class="w-4 h-4 bg-yellow-100 rounded"></div>
                    <span>Careers</span>
                  </div>
                  <div class="flex items-center gap-2">
                    <div class="w-4 h-4 bg-lime-100 rounded"></div>
                    <span>Activities Combined KC</span>
                  </div>
                  <div class="flex items-center gap-2">
                    <div class="w-4 h-4 bg-pink-100 rounded"></div>
                    <span>Targets</span>
                  </div>
                  <div class="flex items-center gap-2">
                    <div class="w-4 h-4 bg-gray-200 rounded"></div>
                    <span>Other/Default</span>
                  </div>
                </div>
              </div>
            </div>
            
            <div class="mb-4">
              <h5 class="font-medium text-gray-800 mb-3">üìã Headers from Uploaded Files</h5>
              <p class="text-sm text-gray-600 mb-3">Optional: assign individually. For speed, use the file-level assignment above.</p>
              <div id="headersList" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-2">
                <!-- Headers will be populated here -->
              </div>
            </div>
            
            <div class="flex flex-col sm:flex-row gap-3 mt-4">
              <button id="applyHeaderAssignments" class="bg-green-600 text-white px-6 py-3 rounded-lg hover:bg-green-700 transition-colors font-medium flex-1">
                ‚úÖ Generate Report
              </button>
              <button id="resetHeaderAssignments" class="bg-gray-500 text-white px-6 py-3 rounded-lg hover:bg-gray-600 transition-colors font-medium">
                üîÑ Reset
              </button>
            </div>
          </div>
        </div>
      </div>

      <!-- Step 3: Template Options (Optional) -->
      <div class="bg-white rounded-lg shadow p-4 sm:p-6">
        <div class="flex items-center mb-3">
          <span class="bg-purple-500 text-white rounded-full w-6 h-6 flex items-center justify-center text-sm font-medium mr-3">3</span>
          <h3 class="text-lg font-medium text-gray-900">Template Options</h3>
          <span class="ml-2 text-sm text-gray-500">(Optional)</span>
        </div>
        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
          <div>
            <label class="block text-sm font-medium text-gray-700 mb-2">Apply Template (Optional)</label>
            <select id="templateSelect" class="border border-gray-300 rounded-md px-3 py-2 w-full text-sm">
              <option value="">-- No template --</option>
            </select>
          </div>
          <div class="flex items-end">
            <button id="applyTemplateBtn" class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 transition-colors font-medium w-full md:w-auto">Apply</button>
          </div>
        </div>
        <!-- Template management actions -->
        <div class="mt-3 flex flex-wrap gap-2">
          <button id="renameTemplateBtn" type="button" class="bg-gray-600 text-white px-4 py-2 rounded hover:bg-gray-700 transition-colors font-medium">Rename Template</button>
          <button id="updateTemplateBtn" type="button" class="bg-green-600 text-white px-4 py-2 rounded hover:bg-green-700 transition-colors font-medium">Update Template From Table</button>
        </div>
        <!-- Template File Type Selection (shown when using templates) -->
        <div id="templateFileTypeSelection" class="mt-4 hidden">
          <h4 class="text-sm font-medium text-gray-700 mb-3">Select file types for template preview:</h4>
          <div id="templateFileTypeList" class="space-y-2">
            <!-- Template file type selections will be populated here -->
          </div>
        </div>
      </div>


      <!-- Step 4: Select College & Filters -->
      <div class="bg-white rounded-lg shadow p-4 sm:p-6 mb-6">
        <div class="flex items-center mb-3">
          <span class="bg-orange-500 text-white rounded-full w-6 h-6 flex items-center justify-center text-sm font-medium mr-3">4</span>
          <h3 class="text-lg font-medium text-gray-900">Select College</h3>
        </div>
        <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
          <div>
            <label class="block text-sm font-medium text-gray-700 mb-2">Account Manager (Optional)</label>
            <select id="accountManagerFilter" class="border border-gray-300 rounded-md px-3 py-2 w-full">
              <option value="">All Account Managers</option>
            </select>
          </div>
          <div>
            <label class="block text-sm font-medium text-gray-700 mb-2">College *</label>
            <select id="collegeSelect" class="border border-gray-300 rounded-md px-3 py-2 w-full">
              <option value="">Select a college...</option>
            </select>
          </div>
        </div>
      </div>

      <!-- Step 5: Generate Final Report -->
      <div class="bg-white rounded-lg shadow p-4 sm:p-6 mb-6">
        <div class="flex items-center mb-3">
          <span class="bg-green-500 text-white rounded-full w-6 h-6 flex items-center justify-center text-sm font-medium mr-3">5</span>
          <h3 class="text-lg font-medium text-gray-900">Generate Report</h3>
        </div>
        <p class="text-gray-600 mb-4">Once you've completed the steps above, generate your final report.</p>
        <button id="finalGenerateBtn" type="button" class="bg-green-600 text-white px-8 py-4 rounded-lg hover:bg-green-700 transition-colors font-medium text-lg w-full sm:w-auto">
          üöÄ Generate Final Report
        </button>
      </div>

      <!-- Data Table Section -->
      <div class="bg-white rounded-lg shadow">
        <div class="px-3 sm:px-6 py-3 sm:py-4 border-b border-gray-200">
          <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center gap-3 sm:gap-0">
            <h3 class="text-base sm:text-lg font-semibold text-gray-900">Data Table</h3>
            <div class="flex items-center gap-3">
              <label class="inline-flex items-center text-sm text-gray-700">
                <input type="checkbox" id="toggleCellBorders" class="mr-2">
                Show cell borders
              </label>
            </div>
          </div>
        </div>
        
        <!-- Top horizontal scrollbar synced with the table below -->
        <div id="tableTopScroll" class="overflow-x-auto custom-scrollbar custom-scrollbar-thick" style="height:16px; border-top:1px solid #e5e7eb; border-bottom:1px solid #e5e7eb;">
          <div id="tableTopScrollInner" style="height:1px;"></div>
        </div>
        
        <div id="tableScrollContainer" class="overflow-x-auto custom-scrollbar custom-scrollbar-thick">
          <!-- File legend (maps header accent colours to filenames) -->
          <div id="fileLegend" class="px-3 sm:px-6 py-2 text-xs text-gray-600 flex flex-wrap gap-2"></div>
          <table id="dataTable" class="min-w-full divide-y divide-gray-200" style="border-collapse:separate;border-spacing:0;">
            <thead id="tableHeader">
              <!-- Headers will be populated here -->
            </thead>
            <tbody id="tableBody" class="bg-white divide-y divide-gray-200">
              <!-- Data will be populated here -->
            </tbody>
          </table>
        </div>
        
        <div class="px-3 sm:px-6 py-3 sm:py-4 border-t border-gray-200">
          <div class="mobile-actions flex flex-col sm:flex-row space-y-2 sm:space-y-0 sm:space-x-4">
            <!-- Editing Controls -->
            <div class="flex flex-wrap gap-2 mb-4 items-center">
              <button id="editToggleBtn" class="bg-blue-600 text-white px-4 sm:px-6 py-2 rounded hover:bg-blue-700 transition-colors duration-200 font-medium shadow-sm touch-button">‚úèÔ∏è Add & Edit</button>
              <div id="editControls" class="flex flex-wrap gap-2 items-center hidden">
              <button id="addColumnBtn" class="bg-green-500 text-white px-4 sm:px-6 py-2 rounded hover:bg-green-600 transition-colors duration-200 font-medium shadow-sm touch-button">
                + Add Column
              </button>
              <button id="deleteColumnBtn" class="bg-red-500 text-white px-4 sm:px-6 py-2 rounded hover:bg-red-600 transition-colors duration-200 font-medium shadow-sm touch-button">
                - Delete Column
              </button>
              <button id="addRowBtn" class="bg-green-500 text-white px-4 sm:px-6 py-2 rounded hover:bg-green-600 transition-colors duration-200 font-medium shadow-sm touch-button">
                + Add Row
              </button>
              <button id="deleteRowBtn" class="bg-red-500 text-white px-4 sm:px-6 py-2 rounded hover:bg-red-600 transition-colors duration-200 font-medium shadow-sm touch-button">
                - Delete Row
              </button>
              <button id="deleteSelectedBtn" type="button" class="bg-red-600 text-white px-4 sm:px-6 py-2 rounded hover:bg-red-700 transition-colors duration-200 font-medium shadow-sm touch-button">üóë Delete Selected</button>
              <button id="moveColLeftBtn" class="bg-gray-600 text-white px-4 sm:px-6 py-2 rounded hover:bg-gray-700 transition-colors duration-200 font-medium shadow-sm touch-button">‚óÄÔ∏é Move Col</button>
              <button id="moveColRightBtn" class="bg-gray-600 text-white px-4 sm:px-6 py-2 rounded hover:bg-gray-700 transition-colors duration-200 font-medium shadow-sm touch-button">Move Col ‚ñ∂Ô∏é</button>
              <button id="moveRowUpBtn" class="bg-gray-600 text-white px-4 sm:px-6 py-2 rounded hover:bg-gray-700 transition-colors duration-200 font-medium shadow-sm touch-button">‚ñ≤ Move Row</button>
              <button id="moveRowDownBtn" class="bg-gray-600 text-white px-4 sm:px-6 py-2 rounded hover:bg-gray-700 transition-colors duration-200 font-medium shadow-sm touch-button">Move Row ‚ñº</button>
              </div>
            </div>
            
            <!-- Report Generation Controls -->
            <button id="exportBtn" type="button" class="bg-blue-500 text-white px-4 sm:px-6 py-2 rounded hover:bg-blue-600 transition-colors duration-200 font-medium shadow-sm touch-button">
              Generate Report
            </button>
            <button id="saveTemplateBtn" class="bg-yellow-500 text-white px-4 sm:px-6 py-2 rounded hover:bg-yellow-600 transition-colors duration-200 font-medium shadow-sm touch-button">
              Save as Template
            </button>
          </div>
        </div>
      </div>

      <!-- Analysis Section -->
      <div id="aiAnalysisSection" class="bg-white rounded-lg shadow p-4 sm:p-6 hidden">
        <h3 class="text-base sm:text-lg font-semibold text-gray-900 mb-4">Analysis</h3>
        <div id="aiAnalysisContent" class="space-y-4">
          <!-- Analysis content will be populated here -->
        </div>
      </div>
    </div>

    <!-- Status Area -->
    <div id="statusArea" class="fixed top-4 right-4 z-50 max-w-md"></div>
  </div>

  <!-- Modals will be added here -->
  
  <script>
    // Ensure cookies (session) are sent with uploads and all API calls
    try { axios.defaults.withCredentials = true; } catch(_) {}
    console.log('=== Script loading started ===');
    console.log('=== Report generation page loaded ===');
    console.log('=== PAGE VERSION: 2025-09-09-14:15 - Process Template Fixed ===');
    
    // Global variables
    let colleges = [];
    let accountManagers = [];
    let tableData = [];
    let tableHeaders = [];
    let tableHeaderColors = []; // Store header colors from Excel files
    let selectedAccountManagerId = null;
    let currentCollegeId = null;
    let previousReportData = null;
    
    // Clear any stale data when page loads
    console.log('üßπ Clearing stale data on page load...');
    try { 
      localStorage.removeItem('excelEditorData'); 
      console.log('‚úÖ Cleared excelEditorData from localStorage');
    } catch(e) { 
      console.warn('‚ö†Ô∏è Could not clear excelEditorData:', e.message); 
    }
    // Also clear any previously saved per-file colour/type selections so a refresh resets colours
    try {
      localStorage.removeItem('fileLevelSelections');
      window.__fileLevelSelections = {};
      console.log('‚úÖ Cleared fileLevelSelections to reset colours on refresh');
    } catch(e) {
      console.warn('‚ö†Ô∏è Could not clear fileLevelSelections:', e.message);
    }
    let isSelectionMode = false; // legacy selection mode
    let editMode = false;        // new edit mode with checkboxes + drag and drop
    let selectedRows = new Set();
    let selectedColumns = new Set();
    let lastSelectedColIndex = null;
    let lastSelectedRowIndex = null;
    let headerFileMap = {}; // Track which file each header came from
    // Ordered list of selected files to control upload order
    window.__selectedFiles = [];

    // Define consistent colors for each section type
    const SECTION_COLORS = {
      'placements': 'bg-blue-100',      // Blue for placements
      'assessments': 'bg-green-200',    // Green for assessments
      'careers': 'bg-orange-100',       // Orange for careers
      'activities': 'bg-yellow-100',    // Yellow for activities
      'activities-combined': 'bg-lime-100', // Lime for Activities Combined KC
      'enrichment': 'bg-teal-100',      // Teal for enrichment (canonical)
      'employment': 'bg-purple-100',    // Purple for employer engagement/employment
      'employer-activity': 'bg-red-100', // Red for employer activities
      'enrichment-activity': 'bg-cyan-100', // Cyan for enrichment activities
      'targets': 'bg-pink-100',         // Pink for targets
      'login': 'bg-indigo-100',         // Indigo for login
      'default': 'bg-gray-100'          // Gray for unknown sections
    };

    // Restore any saved per-file color/type selections so colors persist across actions
    try {
      const savedSelections = localStorage.getItem('fileLevelSelections');
      if (savedSelections) {
        window.__fileLevelSelections = JSON.parse(savedSelections);
        console.log('Restored file-level selections from localStorage:', window.__fileLevelSelections);
      }
    } catch (e) {
      console.warn('Could not restore file-level selections:', e?.message || e);
    }

    // Define consistent colors for Excel export
    const SECTION_COLORS_EXCEL = {
      'placements': 'FFDBEAFE',         // Light blue (matches bg-blue-100)
      'assessments': 'FFBBF7D0',        // Light green (matches bg-green-200)
      'careers': 'FFFED7AA',            // Light orange (matches bg-orange-100)
      'activities': 'FFFEF3C7',         // Light yellow (matches bg-yellow-100)
      'activities-combined': 'FFECFCCB', // Light lime (matches bg-lime-100, Activities Combined KC)
      'enrichment': 'FFCCFBF1',         // Light teal (matches bg-teal-100)
      'employment': 'FFF3E8FF',         // Light purple (matches bg-purple-100)
      'employer-activity': 'FFFEE2E2',  // Light red (matches bg-red-100)
      'enrichment-activity': 'FFE0F7FA',// Light cyan (matches bg-cyan-100)
      'targets': 'FFFCE7F3',            // Light pink (matches bg-pink-100)
      'login': 'FFE0E7FF',              // Light indigo (matches bg-indigo-100)
      'default': 'FFF3F4F6'             // Light gray (matches bg-gray-100)
    };

          // Function to determine section type from header
      function getSectionType(header) {
        const headerLower = header.toLowerCase();
        
        // Compute base text without [Label] and (...) to identify the core metric
        const baseLower = String(header)
          .replace(/\s*\[[^\]]+\]\s*$/, '')
          .replace(/\s*\([^)]*\)\s*$/, '')
          .trim()
          .toLowerCase();
        
        // Placements must be detected FIRST so even headers like
        // "Total Placements (Employer Activity)" remain placements (blue)
        const placementExtras = new Set(['hours scheduled to date','student confirmed','employer confirmed']);
        if (
          baseLower.includes('placement') ||
          placementExtras.has(baseLower) ||
          headerLower.includes('hours scheduled') || headerLower.includes('scheduled to date')
        ) {
          return 'placements';
        }
        
        // Special: Activities Combined KC header patterns
        // Recognise KC-specific activity summary columns and map to the combined category
        try {
          const hl = headerLower;
          const isKCCombined = (
            /^students\s+with\s+\d+\s+enrichment\s+activit/.test(hl) ||
            hl.includes('total students with activities') ||
            hl.includes('% students with activities') ||
            hl.includes('percent students with activities') ||
            hl.includes('total activities') ||
            (hl.includes('activity hours') && !hl.includes('scheduled')) ||
            hl.includes('students with employer engagement activities')
          );
          if (isKCCombined) {
            return 'activities-combined';
          }
        } catch(_) {}
        
        // Then check for explicit engagement/activity suffixes
        if (headerLower.includes('(employer engagement)')) {
          return 'employment';
        }
        if (headerLower.includes('(employer activity)')) {
          return 'employer-activity';
        }
        if (headerLower.includes('(enrichment activity)')) {
          return 'enrichment-activity';
        }
        if (headerLower.includes('(activities-combined)') || headerLower.includes('(activities combined kc)')) {
          return 'activities-combined';
        }
        
        // Then check for content type suffixes from backend processing
        if (headerLower.includes('(enrichment)')) {
          return 'enrichment';
        }
        if (headerLower.includes('(employer)')) {
          return 'employment';
        }
        
        // Check for assessments - broader matching
        if (headerLower.includes('assessment') || headerLower.includes('score') || 
            headerLower.includes('students without') || headerLower.includes('students with') ||
            headerLower.includes('average score')) {
          return 'assessments';
        }
        
        // Check for careers - broader matching to catch all career/job profile related headers
        if (headerLower.includes('career') || headerLower.includes('job profile') || 
            headerLower.includes('quiz') || headerLower.includes('mapped job profile') ||
            headerLower.includes('total mapped job profiles')) {
          return 'careers';
        }
        
        // Check for activities - broader matching
        if (headerLower.includes('activity') || headerLower.includes('hours') && !headerLower.includes('scheduled')) {
          return 'activities';
        }
        
        // Check for employment
        if (headerLower.includes('employment') || headerLower.includes('employ')) {
          return 'employment';
        }
        
        // Check for enrichment
        if (headerLower.includes('enrich')) {
          return 'enrichment';
        }
        
        return 'default';
      }

    // Compute a stable signature for headers to act like a template key when no saved template is selected
    function computeHeaderSignature(headers) {
      try {
        const norm = (h) => {
          try {
            return String(h || '')
              .replace(/\s*\[[^\]]+\]\s*$/, '')
              .replace(/\s*\([^)]*\)\s*$/, '')
              .trim()
              .toLowerCase();
          } catch(_) { return String(h || ''); }
        };
        const cleaned = (Array.isArray(headers) ? headers : [])
          .map(norm)
          .filter(h => h && h !== 'department');
        const uniqueSorted = Array.from(new Set(cleaned)).sort();
        const s = uniqueSorted.join('|');
        let hash = 0;
        for (let i = 0; i < s.length; i++) {
          hash = ((hash << 5) - hash) + s.charCodeAt(i);
          hash |= 0;
        }
        return 'hdr_' + Math.abs(hash).toString(36);
      } catch (_) { return 'hdr_unknown'; }
    }

    // Return a user-facing version of a header without any trailing [FileLabel] suffix
    // e.g., "Hours Scheduled to date [data1]" -> "Hours Scheduled to date"
    function stripFileLabel(h) {
      try {
        return String(h || '').replace(/\s*\[[^\]]+\]\s*$/, '');
      } catch(_) { return h; }
    }

    // Success modal after report generation
    async function showReportSuccessDialog(name, collegeId, reportId, headers, rows, meta) {
      return new Promise((resolve) => {
        const modal = document.createElement('div');
        modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
        modal.innerHTML = `
          <div class="bg-white rounded-lg p-6 max-w-md w-full mx-4 shadow-xl">
            <h3 class="text-lg font-semibold mb-2">Report Generated</h3>
            <p class="text-sm text-gray-700 mb-4">${name} has been saved.</p>
            <div class="flex justify-end gap-2">
              <button id="rptOkBtn" type="button" class="px-4 py-2 rounded bg-gray-200 text-gray-800 hover:bg-gray-300">Close</button>
              <button id="rptDownloadBtn" type="button" class="px-4 py-2 rounded bg-blue-600 text-white hover:bg-blue-700">Download Excel</button>
              <button id="rptViewBtn" type="button" class="px-4 py-2 rounded bg-green-600 text-white hover:bg-green-700">View Reports</button>
            </div>
          </div>`;
        document.body.appendChild(modal);
        const cleanup = () => { try { document.body.removeChild(modal); } catch(_) {} resolve(); };
        modal.addEventListener('click', (e) => { if (e.target === modal) cleanup(); });
        const closeBtn = modal.querySelector('#rptOkBtn');
        const dlBtn = modal.querySelector('#rptDownloadBtn');
        const viewBtn = modal.querySelector('#rptViewBtn');
        if (closeBtn) closeBtn.addEventListener('click', cleanup);
        if (dlBtn) dlBtn.addEventListener('click', async () => {
          try {
            // Build export headers + rows including +/- columns using previousReportData when available
            function shouldHaveChangeColumn(h) {
              const hl = String(h || '').toLowerCase();
              return (
                hl !== 'department' && (
                  hl.includes('percent') || hl.includes('%') ||
                  hl.includes('total') || hl.includes('students') ||
                  hl.includes('hours') || hl.includes('score') ||
                  hl.includes('activities')
                )
              );
            }
            function parseNum(v) {
              if (v == null || v === '') return 0;
              if (typeof v === 'number') return v;
              const s = String(v).trim();
              if (s.endsWith('%')) {
                const p = parseFloat(s.replace('%',''));
                return isNaN(p) ? 0 : p; // keep as 0-100 for difference display
              }
              const n = parseFloat(s.replace(/,/g,''));
              return isNaN(n) ? 0 : n;
            }
            const expHeaders = [];
            const changeIdxMap = new Map();
            (headers || []).forEach((h) => {
              expHeaders.push(h);
              if (shouldHaveChangeColumn(h)) {
                changeIdxMap.set(h, expHeaders.length); // index where +/- will be inserted
                expHeaders.push(`${h} +/-`);
              }
            });
            const prev = (window.previousReportData && Array.isArray(window.previousReportData.rows)) ? window.previousReportData : null;
            const prevMap = new Map();
            if (prev && Array.isArray(prev.rows)) {
              prev.rows.forEach(r => { if (Array.isArray(r) && r.length) prevMap.set(r[0], r); });
            }
            const expRows = (rows || []).map(r => {
              const out = [];
              const dept = Array.isArray(r) ? r[0] : null;
              const prevRow = dept != null ? prevMap.get(dept) : null;
              (headers || []).forEach((h, i) => {
                const val = r[i];
                out.push(val);
                if (changeIdxMap.has(h)) {
                  let prevVal = prevRow && prevRow.length > i ? prevRow[i] : 0;
                  const diff = parseNum(val) - parseNum(prevVal);
                  const shown = (typeof diff === 'number' && !isNaN(diff)) ? (diff > 0 ? `+${diff.toFixed(1)}` : diff.toFixed(1)) : '0';
                  out.push(shown);
                }
              });
              return out;
            });
            const payload = { headers: expHeaders, rows: expRows, name, meta };
            const res = await axios.post('/api/export-excel', payload, { responseType: 'blob' });
            const blob = new Blob([res.data], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a'); a.href = url; a.download = `${name.replace(/[^a-zA-Z0-9_-]/g,'_')}.xlsx`; document.body.appendChild(a); a.click(); a.remove();
            window.URL.revokeObjectURL(url);
          } catch (e) { showStatus('Excel download failed: ' + (e?.message || e), 'error'); }
        });
        if (viewBtn) viewBtn.addEventListener('click', () => {
          try { window.open(`/college-dashboard.html?tab=reports&id=${encodeURIComponent(collegeId)}`, '_blank'); } catch (_) {}
          cleanup();
        });
        const onKey = (e) => { if (e.key === 'Escape' || e.key === 'Enter') { e.preventDefault(); cleanup(); window.removeEventListener('keydown', onKey, true); } };
        window.addEventListener('keydown', onKey, true);
      });
    }


    // Initialize the application
    document.addEventListener('DOMContentLoaded', function() {
      console.log('=== DOMContentLoaded event fired ===');
      checkAuthStatus();
      setupEventListeners();
      loadInitialData();

      // Restore border toggle state and bind listener
      try {
        const dataTable = document.getElementById('dataTable');
        const borderToggle = document.getElementById('toggleCellBorders');
        if (dataTable && borderToggle) {
          const saved = localStorage.getItem('tableBordersOn');
          const on = saved === 'true';
          borderToggle.checked = on;
          if (on) dataTable.classList.add('borders-on'); else dataTable.classList.remove('borders-on');
          borderToggle.addEventListener('change', () => {
            if (borderToggle.checked) {
              dataTable.classList.add('borders-on');
              localStorage.setItem('tableBordersOn', 'true');
            } else {
              dataTable.classList.remove('borders-on');
              localStorage.setItem('tableBordersOn', 'false');
            }
          });
        }
      } catch (e) { console.warn('Border toggle init failed:', e?.message || e); }
      
      // Initialize sticky header toggle (default OFF to preserve header colours)
      try {
        const stickyToggle = document.getElementById('toggleStickyHeader');
        if (stickyToggle) {
          stickyToggle.checked = false;
          applyStickyHeader(false);
          stickyToggle.addEventListener('change', () => {
            const on = !!stickyToggle.checked;
            applyStickyHeader(on);
          });
          // Do not persist this setting to avoid unexpected overrides of colours
        }
      } catch (e) { console.warn('Sticky header toggle init failed:', e?.message || e); }
      
      // Initialize top/bottom scroll sync once DOM is ready
      try { setupScrollSync(); } catch (e) { console.warn('Scroll sync setup failed:', e?.message || e); }
    });

    // Helper: robust department header detection
    function isDepartmentHeader(h) {
      try { return String(h || '').trim().toLowerCase().startsWith('department'); } catch (_) { return false; }
    }

    // Enable/disable sticky headers on the data table by setting inline styles on th
    function applyStickyHeader(on) {
      try {
        const ths = document.querySelectorAll('#dataTable thead th');
        ths.forEach(th => {
          if (on) {
            th.style.setProperty('position', 'sticky', 'important');
            th.style.setProperty('top', '0', 'important');
            th.style.setProperty('z-index', '20', 'important');
            // Do NOT set background here; preserve header section colours
          } else {
            th.style.removeProperty('position');
            th.style.removeProperty('top');
            th.style.removeProperty('z-index');
            // Do NOT remove background; preserve inline/background-color from header renderer
          }
        });
      } catch (_) {}
    }

    // Top/bottom horizontal scroll synchronization for the data table
    let __scrollSyncInitialized = false;
    function setupScrollSync() {
      const top = document.getElementById('tableTopScroll');
      const bottom = document.getElementById('tableScrollContainer');
      const inner = document.getElementById('tableTopScrollInner');
      const table = document.getElementById('dataTable');
      if (!top || !bottom || !inner || !table) return;
      const update = () => {
        try { inner.style.width = Math.max(bottom.scrollWidth, table.scrollWidth) + 'px'; } catch (_) {}
      };
      update();
      let syncing = false;
      if (!__scrollSyncInitialized) {
        top.addEventListener('scroll', () => { if (syncing) return; syncing = true; bottom.scrollLeft = top.scrollLeft; syncing = false; });
        bottom.addEventListener('scroll', () => { if (syncing) return; syncing = true; top.scrollLeft = bottom.scrollLeft; syncing = false; });
        window.addEventListener('resize', update);
        __scrollSyncInitialized = true;
      }
      // In case dimensions change after paint
      setTimeout(update, 0);
    }
    function updateScrollSync() {
      try {
        const inner = document.getElementById('tableTopScrollInner');
        const bottom = document.getElementById('tableScrollContainer');
        const table = document.getElementById('dataTable');
        if (inner && bottom && table) {
          inner.style.width = Math.max(bottom.scrollWidth, table.scrollWidth) + 'px';
        }
      } catch (_) {}
    }

    // Authentication check
    async function checkAuthStatus() {
      try {
        const response = await axios.get('/api/auth/me');
        if (response.data.success) {
          document.getElementById('userInfo').classList.remove('hidden');
          document.getElementById('logoutBtn').classList.remove('hidden');
          document.getElementById('userName').textContent = response.data.user.name;
          document.getElementById('userRole').textContent = response.data.user.role;
        } else {
          window.location.href = '/login';
        }
      } catch (error) {
        console.error('Auth check failed:', error);
        window.location.href = '/login';
      }
    }

    // Resolve the file label for a given header using headerFileMap and fileInfo
    function getFileLabelForHeader(header) {
      try {
        if (!header) return null;
        // 1) If the header already contains a [Label] suffix, extract it directly
        const m = String(header).match(/\[([^\]]+)\]\s*$/);
        if (m && m[1]) {
          return m[1];
        }
        // 2) Otherwise, consult headerFileMap to find the originating file and return its label
        if (!window.headerFileMap || !Array.isArray(window.fileInfo)) return null;
        const base = String(header).replace(/ \(Employer Engagement\)| \(Enrichment\)/, '').trim();
        const candidates = [
          header,
          base,
          base.replace(/ \(.*\)$/,'').trim(),
          `${base} (enrichment)`,
          `${base} (employer)`,
          `${base} (employment)`
        ];
        let idx;
        // Try direct key hit first
        for (const k of candidates) {
          if (window.headerFileMap[k] !== undefined) { idx = window.headerFileMap[k]; break; }
        }
        // If not found, try case-insensitive lookup across keys
        if (idx === undefined) {
          const mapEntries = Object.entries(window.headerFileMap);
          const lower = candidates.map(c => c.toLowerCase());
          for (const [mk, mv] of mapEntries) {
            if (lower.includes(String(mk).toLowerCase())) { idx = mv; break; }
          }
        }
        if (idx === undefined || idx === null) return null;
        const fi = window.fileInfo[idx];
        return fi && (fi.label || fi.originalName || fi.filename) ? (fi.label || fi.originalName || fi.filename) : null;
      } catch (_) { return null; }
    }

    // Resolve the content type for a given header using headerFileMap -> fileInfo
    function getContentTypeForHeader(header) {
      try {
        if (!header || !window.headerFileMap || !Array.isArray(window.fileInfo)) return null;
        const base = String(header).replace(/ \(Employer Engagement\)| \(Enrichment\)/, '').trim();
        const candidates = [header, base, base.replace(/ \(.*\)$/,'')];
        let idx;
        for (const k of candidates) {
          if (window.headerFileMap[k] !== undefined) { idx = window.headerFileMap[k]; break; }
        }
        if (idx === undefined || idx === null) return null;
        const fi = window.fileInfo[idx];
        return fi && fi.contentType ? String(fi.contentType).toLowerCase() : null;
      } catch (_) { return null; }
    }

    // Unified cell value resolver for all sections (placements, assessments, careers, enrichment, employer engagement)
    function resolveCellValue(header, dept, data) {
      try {
        let metrics = (data.metrics || {})[dept] || {};
        let emp = data.activities?.employerEngagement?.[dept] || {};
        let enr = data.activities?.enrichment?.[dept] || {};

        // Fuzzy department match: align rows like "D-BEAUTY" with source keys like "D Beauty" or "Beauty"
        try {
          const norm = s => String(s || '').toLowerCase().replace(/[^a-z0-9]+/g, ' ').replace(/\s+/g, ' ').trim();
          if ((!metrics || Object.keys(metrics).length === 0) && Array.isArray(data.departments)) {
            const want = norm(dept);
            const found = (data.departments || []).find(d => norm(d) === want);
            if (found && found !== dept) {
              metrics = (data.metrics || {})[found] || metrics;
              emp = data.activities?.employerEngagement?.[found] || emp;
              enr = data.activities?.enrichment?.[found] || enr;
            } else if (!found) {
              // Secondary: partial containment if exact normalized match not found
              const found2 = (data.departments || []).find(d => {
                const nd = norm(d);
                return nd && (nd.includes(want) || want.includes(nd));
              });
              if (found2 && found2 !== dept) {
                metrics = (data.metrics || {})[found2] || metrics;
                emp = data.activities?.employerEngagement?.[found2] || emp;
                enr = data.activities?.enrichment?.[found2] || enr;
              }
            }
          }
        } catch (_) {}

        // Activity tag detection: Employer Engagement/Activity => employer; Enrichment Activity => enrichment.
        // Also treat enrichment/employer engagement words without suffix when header text clearly denotes activities.
        const hasEmpEngagementTag = /\(Employer Engagement\)/i.test(header);
        const hasEmpActivityTag = /\(Employer Activity\)/i.test(header);
        const hasEnrichmentTag = /\(Enrichment\)/i.test(header);
        const hasEnrichmentActivityTag = /\(Enrichment Activity\)/i.test(header);
        const label = getFileLabelForHeader(header);

        let base = String(header)
          .replace(/\s*\[[^\]]+\]\s*$/, '')
          .replace(/\s*\((Employer Engagement|Employer Activity|Enrichment|Enrichment Activity|[^)]*)\)\s*$/i, '')
          .trim();

        const suffixEmp = ' (Employer Engagement)';
        const suffixEnr = ' (Enrichment)';

        // Build candidate variants in descending priority
        const variantsFor = (b, lab, withEmp) => {
          const sfx = withEmp ? suffixEmp : suffixEnr;
          const arr = [];
          if (lab) arr.push(`${b}${sfx} [${lab}]`);
          if (lab) arr.push(`${b} [${lab}]`);
          arr.push(`${b}${sfx}`);
          arr.push(b);
          return arr;
        };


        // Resolve activity type hint from header or mapping
        // Base text (without labels/suffixes)
        let t = '';
        const activityBases = new Set([
          'total students',             // Total students in activity files
          'students with activities',
          'total activities',
          'students with activities', // covers "% Students with Activities" after % removal
          'total activity hours'
        ]);
        // Placements-related bases that don't contain the word "placements" but belong to placements
        const placementExtraBases = new Set([
          'hours scheduled to date',
          'student confirmed',
          'employer confirmed'
        ]);
        const normBase = (s => s.toLowerCase().replace(/%/g, '').replace(/\s+/g, ' ').trim())(
          String(header)
            .replace(/\s*\[[^\]]+\]\s*$/, '')
            .replace(/\s*\((Employer Engagement|Employer Activity|Enrichment|Enrichment Activity|[^)]*)\)\s*$/i, '')
        );
        const isPlacementBase = /\bplacement(s)?\b/i.test(normBase) || placementExtraBases.has(normBase);
        if (isPlacementBase) {
          // Placements are regular metrics sourced from placements files, not activities
          t = '';
        } else if (hasEmpEngagementTag || hasEmpActivityTag) {
          t = 'employer';
        } else if (hasEnrichmentActivityTag || (hasEnrichmentTag && activityBases.has(normBase))) {
          t = 'enrichment';
        }
        // New: infer from plain text when suffixes are absent
        if (!t) {
          const norm = normBase;
          if (/\benrichment\b/.test(norm) && /\bactivit/i.test(norm)) t = 'enrichment';
          else if (/\bemployer\s+engagement\b/.test(norm) && /\bactivit/i.test(norm)) t = 'employer';
        }
        const hasExplicitSuffix = hasEmpEngagementTag || hasEmpActivityTag || hasEnrichmentActivityTag;

        // Activity lookups with graceful fallback to regular metrics when values are stored as metrics (e.g., activities-combined files)
        if (t === 'employer' || t === 'enrichment') {
          const map = (t === 'employer') ? emp : enr;
          const primary = variantsFor(base, label, t === 'employer');
          for (const k of primary) { if (map[k] !== undefined) return map[k]; }
          
          // Try direct base lookup (backend now stores both with and without label)
          if (map[base] !== undefined) return map[base];
          
          // Fuzzy: strip [label] and any (...) from keys
          const baseLower = base.toLowerCase();
          const fuzzyFind = obj => {
            const mk = Object.keys(obj).find(k => {
              const stripped = k
                .replace(/\s*\[[^\]]+\]\s*$/, '')
                .replace(/\s*\([^)]*\)\s*$/, '')
                .trim().toLowerCase();
              if (stripped === baseLower) return true;
              if (stripped.endsWith('s') && stripped.slice(0, -1) === baseLower) return true;
              if (baseLower.endsWith('s') && baseLower.slice(0, -1) === stripped) return true;
              return false;
            });
            return mk ? obj[mk] : undefined;
          };
          const fuzzyPrimary = fuzzyFind(map);
          if (fuzzyPrimary !== undefined) return fuzzyPrimary;

          // Graceful fallback: some special files (e.g., Activities Combined KC) store these values as regular metrics
          // with a different content type (e.g., activities-combined). Attempt regular metrics resolution.
          try {
            const type2 = getContentTypeForHeader(header);
            const base2 = base;
            const candidates = [];
            if (type2 && label) candidates.push(`${base2} (${type2}) [${label}]`);
            if (label) candidates.push(`${base2} [${label}]`);
            if (type2) candidates.push(`${base2} (${type2})`);
            candidates.push(base2);
            for (const k of candidates) { if (metrics[k] !== undefined) return metrics[k]; }
            // Fuzzy across metrics keys when typed candidates fail
            const baseLower2 = base2.toLowerCase();
            const mk2 = Object.keys(metrics).find(k => {
              const stripped = String(k)
                .replace(/\s*\[[^\]]+\]\s*$/, '')
                .replace(/\s*\([^)]*\)\s*$/, '')
                .trim().toLowerCase();
              if (stripped === baseLower2) return true;
              if (stripped.endsWith('s') && stripped.slice(0, -1) === baseLower2) return true;
              if (baseLower2.endsWith('s') && baseLower2.slice(0, -1) === stripped) return true;
              return false;
            });
            if (mk2) return metrics[mk2];
          } catch(_) {}
          return '';
        }

        // Regular metrics (placements, assessments, careers, etc.)
        let type = getContentTypeForHeader(header);
        const base2 = String(header).replace(/ \([^)]*\)$/, '').trim();
        // If this looks like a placements metric, force placements type regardless of headerFileMap
        const placementBasesSet = new Set(['hours scheduled to date','student confirmed','employer confirmed']);
        const isPlacementMetric = /\bplacement(s)?\b/i.test(base2) || placementBasesSet.has(base2.toLowerCase());
        if (isPlacementMetric) type = 'placements';
        const candidates = [];
        if (type && label) candidates.push(`${base2} (${type}) [${label}]`);
        if (label) candidates.push(`${base2} [${label}]`);
        if (type) candidates.push(`${base2} (${type})`);
        candidates.push(base2);
        for (const k of candidates) { if (metrics[k] !== undefined) return metrics[k]; }
        
        // Fuzzy metrics lookup: strip [Label] and (...) and compare case-insensitively
        try {
          const baseLower = base2.toLowerCase();
          const mk = Object.keys(metrics).find(k => {
            const stripped = String(k)
              .replace(/\s*\[[^\]]+\]\s*$/, '')
              .replace(/\s*\([^)]*\)\s*$/, '')
              .trim().toLowerCase();
            if (stripped === baseLower) return true;
            if (stripped.endsWith('s') && stripped.slice(0, -1) === baseLower) return true;
            if (baseLower.endsWith('s') && baseLower.slice(0, -1) === stripped) return true;
            return false;
          });
          if (mk) return metrics[mk];
        } catch(_) {}
        
        // Ultra-fuzzy: match base header against any metric key (ignoring labels/types)
        try {
          const needle = base2.toLowerCase().replace(/\s+/g, ' ').trim();
          if (needle.length > 3) {
            const mk3 = Object.keys(metrics).find(k => {
              const hay = String(k)
                .replace(/\s*\[[^\]]+\]\s*$/, '')
                .replace(/\s*\([^)]*\)\s*$/, '')
                .toLowerCase().replace(/\s+/g, ' ').trim();
              return hay === needle;
            });
            if (mk3 !== undefined) return metrics[mk3];
          }
        } catch(_) {}
        
        // Last resort: partial match for activity-related headers
        try {
          const searchTerm = header.toLowerCase().replace(/\s+/g, ' ').trim();
          if (searchTerm.includes('total') && searchTerm.includes('activit')) {
            const found = Object.keys(metrics).find(k => {
              const kl = k.toLowerCase();
              return kl.includes('total') && kl.includes('activit') && !kl.includes('hour') && !kl.includes('student');
            });
            if (found !== undefined) return metrics[found];
          }
        } catch(_) {}
        
        return '';
      } catch (e) {
        return '';
      }
    }

    // Load initial data
    async function loadInitialData() {
      try {
        await Promise.all([
          loadColleges(),
          loadAccountManagers(),
          loadTemplates()
        ]);
      } catch (error) {
        console.error('Error loading initial data:', error);
        showStatus('Error loading data: ' + error.message, 'error');
      }
    }

    // Event listeners
    function setupEventListeners() {
      // File processing
      const processBtn = document.getElementById('processBtn');
      if (processBtn) {
        console.log('=== Adding click listener to processBtn ===');
        processBtn.addEventListener('click', function() {
          console.log('=== Process button clicked ===');
          extractHeadersOnly();
        });
      } else {
        console.error('=== processBtn not found ===');
      }
      // Track and render selected files for reordering
      const fileInputEl = document.getElementById('fileInput');
      if (fileInputEl) {
        fileInputEl.addEventListener('change', (e) => {
          try {
            window.__selectedFiles = Array.from(e.target.files || []);
            renderSelectedFilesList();
          } catch (err) {
            console.warn('Failed to capture selected files:', err?.message || err);
          }
        });
      }
      
      const testActivityBtn = document.getElementById('testActivityBtn');
      if (testActivityBtn) {
        testActivityBtn.addEventListener('click', testActivityProcessing);
      }
        const openExcelEditorBtn = document.getElementById('openExcelEditorBtn');
        if (openExcelEditorBtn) {
          openExcelEditorBtn.addEventListener('click', () => {
            // If a template is selected, prefer that
            const sel = document.getElementById('templateSelect');
            const selId = sel && sel.value ? sel.value : '';
            if (selId && Array.isArray(window.__templates)) {
              const tpl = window.__templates.find(t => String(t.id) === String(selId));
              if (tpl && Array.isArray(tpl.headers) && Array.isArray(tpl.tableData)) {
                localStorage.setItem('excelEditorData', JSON.stringify({ 
                  headers: tpl.headers, 
                  rows: tpl.tableData,
                  templateId: tpl.id,
                  templateName: tpl.name,
                  templateDescription: tpl.description,
                  isTemplate: true
                }));
              }
            } else if (Array.isArray(tableHeaders) && Array.isArray(tableData) && tableHeaders.length) {
              const rows = tableData.map(r => r);
              localStorage.setItem('excelEditorData', JSON.stringify({ headers: tableHeaders, rows }));
            }
            const hint = document.getElementById('excelEditorHint');
            if (hint) hint.classList.remove('hidden');
            // Prefer Luckysheet editor for richer formatting/formulas
            const editorUrl = new URL('report-editor-xs.html', window.location.origin);
            // Ensure newest data is used: clear stale cache, then set fresh
            try { localStorage.removeItem('excelEditorData'); } catch(_) {}
            try { localStorage.setItem('excelEditorData', JSON.stringify({ headers: tableHeaders, rows, isTemplate: false })); } catch(_) {}
            // Add cache-bust param in case the editor tab gets reused
            editorUrl.searchParams.set('t', String(Date.now()));
            if (window.currentCollegeId) {
              editorUrl.searchParams.set('collegeId', String(window.currentCollegeId));
            }
            window.open(editorUrl.toString(), '_blank');
          });
        }

      // Auto-load data carried back from the Excel editor so users don't need to reupload
      (function restoreFromExcelIfAvailable(){
        const params = new URLSearchParams(location.search);
        if (params.get('fromExcel') === '1') {
          try {
            const cached = localStorage.getItem('excelEditorData');
            if (cached) {
              const parsed = JSON.parse(cached);
              const headers = parsed.headers || [];
              const rows = parsed.rows || [];
              if (headers.length && rows.length) {
                window.tableHeaders = headers;
                window.tableData = rows;
                renderTable();
                const hint = document.getElementById('excelEditorHint');
                if (hint) hint.classList.remove('hidden');
                showStatus('Restored data from Excel editor', 'success');
              }
            }
          } catch (e) { console.warn('Restore from Excel failed:', e); }
        }
      })();

      // Listen for updates from the Excel editor and refresh the table in place
      window.addEventListener('message', (event) => {
        try {
          const data = event && event.data ? event.data : {};
          if (data && data.type === 'excel-editor-saved') {
            const cached = localStorage.getItem('excelEditorData');
            if (!cached) return;
            const parsed = JSON.parse(cached);
            const headers = parsed.headers || [];
            const rows = parsed.rows || [];
            if (headers.length && rows.length) {
              window.tableHeaders = headers;
              window.tableData = rows;
              renderTable();
              const hint = document.getElementById('excelEditorHint');
              if (hint) hint.classList.remove('hidden');
              showStatus('Updated from Excel editor', 'success');
            }
          }
        } catch (e) {
          console.warn('Message handling from Excel editor failed:', e);
        }
      });
      
      // Table editing
      const addRowBtn = document.getElementById('addRowBtn');
      if (addRowBtn) {
        addRowBtn.addEventListener('click', addRow);
      }
      
      const addColumnBtn = document.getElementById('addColumnBtn');
      if (addColumnBtn) {
        addColumnBtn.addEventListener('click', addColumn);
      }
      
      const deleteBtn = document.getElementById('deleteBtn');
      if (deleteBtn) {
        deleteBtn.addEventListener('click', smartDelete);
      }
      
      const cancelSelectionBtn = document.getElementById('cancelSelectionBtn');
      if (cancelSelectionBtn) {
        cancelSelectionBtn.addEventListener('click', toggleSelectionMode);
      }
      
      const saveAsTemplateBtn = document.getElementById('saveAsTemplateBtn');
      if (saveAsTemplateBtn) {
        saveAsTemplateBtn.addEventListener('click', showSaveTemplateModal);
      }
      
      // Report generation
      const exportBtn = document.getElementById('exportBtn');
      if (exportBtn) {
        exportBtn.addEventListener('click', generateReport);
      }
      
      const saveTemplateBtn = document.getElementById('saveTemplateBtn');
      if (saveTemplateBtn) {
        saveTemplateBtn.addEventListener('click', showSaveTemplateModal);
      }
      
      // Account manager filtering
      const accountManagerFilter = document.getElementById('accountManagerFilter');
      if (accountManagerFilter) {
        accountManagerFilter.addEventListener('change', function() {
          const newValue = this.value ? this.value : null;
          selectedAccountManagerId = newValue;
          updateCollegeSelect();
        });
      }
      
      // College selection
      const collegeSelect = document.getElementById('collegeSelect');
      if (collegeSelect) {
        collegeSelect.addEventListener('change', async function() {
          const collegeId = this.value;
          currentCollegeId = collegeId ? parseInt(collegeId) : null;
          
          if (collegeId) {
            await loadPreviousReportData(parseInt(collegeId));
          } else {
            previousReportData = null;
          }
          
          if (tableData.length > 0) {
            renderTable();
          }
        });
        
        updateCollegeSelect();
      }
      
      
      // Template selection event listener (selection only; use Apply button to apply)
      const templateSelect = document.getElementById('templateSelect');
      if (templateSelect) {
        templateSelect.addEventListener('change', async function() {
          const selectedTemplate = getSelectedTemplate();
          const applyBtn = document.getElementById('applyTemplateBtn');
          if (applyBtn) applyBtn.disabled = !selectedTemplate;
          if (selectedTemplate) {
            console.log('Template selected:', selectedTemplate.name);
            showStatus(`Template "${selectedTemplate.name}" selected. Click Apply to apply.`, 'info');
          } else {
            showStatus('Template deselected - using new data structure', 'info');
          }
        });
      }

      // Apply button wiring
      const applyTemplateBtn = document.getElementById('applyTemplateBtn');
      if (applyTemplateBtn) {
        applyTemplateBtn.addEventListener('click', async function() {
          await applySelectedTemplate();
        });
      }
      // Template management button wiring
      const renameTemplateBtn = document.getElementById('renameTemplateBtn');
      if (renameTemplateBtn) {
        renameTemplateBtn.addEventListener('click', showRenameTemplateModal);
      }
      const updateTemplateBtn = document.getElementById('updateTemplateBtn');
      if (updateTemplateBtn) {
        updateTemplateBtn.addEventListener('click', updateSelectedTemplateFromTable);
      }

      // Ensure the edit toolbar is bound after DOM is ready
      try {
        initializeEditing();
        console.log('Editing toolbar initialized');
      } catch (e) {
        console.warn('Editing toolbar init failed:', e?.message || e);
      }
    }

    // Data loading functions
    async function loadColleges() {
      try {
        const response = await axios.get('/api/colleges');
        if (response.data && response.data.colleges) {
          colleges = response.data.colleges;
        } else if (Array.isArray(response.data)) {
          colleges = response.data;
        } else {
          colleges = [];
        }
        updateCollegeSelect();
      } catch (error) {
        console.error('Error loading colleges:', error);
        showStatus('Error loading colleges: ' + error.message, 'error');
      }
    }

    async function loadAccountManagers() {
      try {
        const response = await axios.get('/api/account-managers');
        accountManagers = response.data;
        updateAccountManagerSelects();
      } catch (error) {
        console.error('Error loading account managers:', error);
        showStatus('Error loading account managers: ' + error.message, 'error');
      }
    }

    async function loadTemplates() {
      try {
        console.log('Loading templates...');
        const response = await axios.get('/api/templates');
        console.log('Templates response:', response.data);
        const apiData = response.data;
        const list = Array.isArray(apiData) ? apiData : (Array.isArray(apiData.templates) ? apiData.templates : []);
        
        console.log('Parsed templates list:', list);
        
        // Store templates globally so they can be accessed by other functions
        window.__templates = list;
        
        const templateSelect = document.getElementById('templateSelect');
        if (templateSelect) {
          const options = '<option value="">No template - Use new data structure</option>' +
            list.map(template => `<option value="${template.id}">${template.name}</option>`).join('');
          console.log('Template options HTML:', options);
          templateSelect.innerHTML = options;
          console.log('Templates loaded successfully, dropdown populated with', list.length, 'templates');
        } else {
          console.error('Template select element not found');
        }
      } catch (error) {
        console.error('Error loading templates:', error);
        console.error('Error details:', error.response?.data || error.message);
        
        // Show error to user
        showStatus('Failed to load templates: ' + (error.response?.data?.error || error.message), 'error');
      }
    }

    // Update functions
    function updateCollegeSelect() {
      const select = document.getElementById('collegeSelect');
      if (!select) return;
      
      if (!colleges || !Array.isArray(colleges)) {
        select.innerHTML = '<option value="">Error loading colleges...</option>';
        return;
      }
      
      let filteredColleges = colleges;
      
      if (selectedAccountManagerId) {
        filteredColleges = colleges.filter(college => 
          String(college.accountManagerId) === String(selectedAccountManagerId)
        );
      }
      
      select.innerHTML = '<option value="">Select a college...</option>' +
        filteredColleges.map(college => `<option value="${college.id}">${college.name}</option>`).join('');
    }

    function updateAccountManagerSelects() {
      if (!accountManagers || !Array.isArray(accountManagers)) {
        accountManagers = [];
      }
      
      const filterSelect = document.getElementById('accountManagerFilter');
      if (filterSelect) {
        filterSelect.innerHTML = '<option value="">All Account Managers</option>' +
          accountManagers.map(am => `<option value="${am.id}">${am.name}</option>`).join('');
      }
    }

    // Load previous report data for change tracking
    async function loadPreviousReportData(collegeId) {
      try {
        const response = await axios.get(`/api/previous-report/${collegeId}`);
        if (response.data.success && response.data.previousData) {
          previousReportData = response.data.previousData.data;
          console.log('Loaded previous report data:', previousReportData);
        } else {
          previousReportData = null;
        }
      } catch (error) {
        console.error('Error loading previous report data:', error);
        previousReportData = null;
      }
    }

    // File processing
    // Global variable to store extracted headers for manual assignment
    let extractedHeaders = null;
    let extractedData = null;
    
    // Returns the current ordered list of files to upload
    function getOrderedFiles() {
      try {
        if (Array.isArray(window.__selectedFiles) && window.__selectedFiles.length) {
          return window.__selectedFiles;
        }
        const fi = document.getElementById('fileInput');
        return fi && fi.files ? Array.from(fi.files) : [];
      } catch (_) {
        const fi = document.getElementById('fileInput');
        return fi && fi.files ? Array.from(fi.files) : [];
      }
    }
    
    // Render selected files with Up/Down controls to change order
    function renderSelectedFilesList() {
      const container = document.getElementById('selectedFilesList');
      if (!container) return;
      const files = getOrderedFiles();
      if (!files.length) {
        container.innerHTML = '';
        return;
      }
      const items = files.map((f, idx) => {
        const upDisabled = idx === 0 ? 'opacity-40 cursor-not-allowed' : '';
        const downDisabled = idx === files.length - 1 ? 'opacity-40 cursor-not-allowed' : '';
        return `
          <div class="flex items-center justify-between border border-gray-200 rounded px-3 py-2 bg-white file-item" draggable="true" data-index="${idx}">
            <div class="text-sm text-gray-800 truncate">
              <span class="inline-block w-6 text-gray-500">${idx + 1}.</span>
              <span title="${f.name}">${f.name}</span>
            </div>
            <div class="flex gap-2">
              <button type="button" class="px-2 py-1 text-sm bg-gray-100 rounded border border-gray-300 hover:bg-gray-200 ${upDisabled}" onclick="moveSelectedFile(${idx}, -1)" title="Move up">‚ñ≤</button>
              <button type="button" class="px-2 py-1 text-sm bg-gray-100 rounded border border-gray-300 hover:bg-gray-200 ${downDisabled}" onclick="moveSelectedFile(${idx}, 1)" title="Move down">‚ñº</button>
            </div>
          </div>`;
      }).join('');
      container.innerHTML = `
        <div class="text-sm text-gray-700 mb-2">Reorder files (top = first columns in report)</div>
        <div class="space-y-2">${items}</div>
      `;
      // Attach drag-and-drop handlers after rendering
      attachSelectedFilesDnD();
    }
    
    // Add drag-and-drop behavior to file items
    function attachSelectedFilesDnD() {
      const container = document.getElementById('selectedFilesList');
      if (!container) return;
      const items = container.querySelectorAll('.file-item');
      items.forEach(item => {
        item.addEventListener('dragstart', onFileItemDragStart);
        item.addEventListener('dragover', onFileItemDragOver);
        item.addEventListener('drop', onFileItemDrop);
        item.addEventListener('dragend', onFileItemDragEnd);
        item.addEventListener('dragleave', onFileItemDragLeave);
      });
    }

    let __dragSourceIndex = null;
    function onFileItemDragStart(e) {
      try {
        const el = e.currentTarget;
        __dragSourceIndex = parseInt(el.getAttribute('data-index'), 10);
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/plain', String(__dragSourceIndex));
        el.classList.add('ring-2', 'ring-blue-300', 'bg-blue-50');
      } catch (_) {}
    }
    function onFileItemDragOver(e) {
      e.preventDefault();
      try {
        const el = e.currentTarget;
        e.dataTransfer.dropEffect = 'move';
        el.classList.add('bg-gray-50');
      } catch (_) {}
    }
    function onFileItemDragLeave(e) {
      try {
        const el = e.currentTarget;
        el.classList.remove('bg-gray-50');
      } catch (_) {}
    }
    function onFileItemDrop(e) {
      e.preventDefault();
      try {
        const el = e.currentTarget;
        el.classList.remove('bg-gray-50');
        const fromStr = e.dataTransfer.getData('text/plain');
        const from = parseInt(fromStr, 10);
        const to = parseInt(el.getAttribute('data-index'), 10);
        if (!Number.isInteger(from) || !Number.isInteger(to) || from === to) return;
        const files = Array.from(window.__selectedFiles || []);
        const [moved] = files.splice(from, 1);
        files.splice(to, 0, moved);
        window.__selectedFiles = files;
        renderSelectedFilesList();
      } catch (_) {}
    }
    function onFileItemDragEnd(e) {
      try {
        const el = e.currentTarget;
        el.classList.remove('ring-2', 'ring-blue-300', 'bg-blue-50', 'bg-gray-50');
      } catch (_) {}
      __dragSourceIndex = null;
    }

    // Move a selected file up (-1) or down (+1) in the order
    function moveSelectedFile(index, direction) {
      try {
        const files = Array.from(window.__selectedFiles || []);
        const newIndex = index + direction;
        if (newIndex < 0 || newIndex >= files.length) return;
        const tmp = files[index];
        files[index] = files[newIndex];
        files[newIndex] = tmp;
        window.__selectedFiles = files;
        renderSelectedFilesList();
      } catch (e) {
        console.warn('Failed to move file:', e?.message || e);
      }
    }
    
    async function extractHeadersOnly() {
      console.log('=== extractHeadersOnly called ===');
      
      const fileInput = document.getElementById('fileInput');
      if (!fileInput.files.length) {
        showStatus('Please select files to process', 'error');
        return;
      }
      
      console.log(`Extracting headers from ${fileInput.files.length} files:`, Array.from(fileInput.files).map(f => f.name));
      
      const formData = new FormData();
      const orderedFiles = getOrderedFiles();
      for (const file of orderedFiles) {
        formData.append('files', file);
      }
      
      // Add flag to only extract headers
      formData.append('extractHeadersOnly', 'true');
      
      showStatus('Extracting headers from files...', 'info');
      
      try {
        const response = await axios.post('/api/upload', formData);
        console.log('Header extraction response:', response.data);
        
        if (response.data.success) {
          extractedHeaders = response.data.headers;
          extractedData = response.data;
          
          // Show manual assignment interface
          showHeaderAssignmentInterface(extractedHeaders);
          showStatus('Headers extracted successfully! Click on headers below to assign them to sections.', 'success');
        } else {
          throw new Error(response.data.error || 'Header extraction failed');
        }
      } catch (error) {
        console.error('Header extraction error:', error);
        showStatus(`Header extraction failed: ${error.message}`, 'error');
      }
    }
    
    async function processFiles() {
      console.log('=== processFiles called ===');
      
      // Reset the original headers flag for regular file processing
      window.useOriginalHeaders = false;
      tableHeaderColors = []; // Clear any template colors
      
      const useTplCheckbox = document.getElementById('useTemplateForPreview');
      const shouldUseTemplateForPreview = !!(useTplCheckbox && useTplCheckbox.checked);
      console.log('Use template for preview:', shouldUseTemplateForPreview);
      
      const fileInput = document.getElementById('fileInput');
      if (!fileInput.files.length) {
        showStatus('Please select files to process', 'error');
        return;
      }
      
      console.log(`Processing ${fileInput.files.length} files:`, Array.from(fileInput.files).map(f => f.name));
      
      const formData = new FormData();
      const orderedFiles2 = getOrderedFiles();
      for (const file of orderedFiles2) {
        formData.append('files', file);
        console.log(`Added file to FormData (ordered): ${file.name}`);
      }
      
      showStatus('Processing files...', 'info');
      
      try {
        console.log('Sending upload request...');
        const response = await axios.post('/api/upload', formData);
        console.log('Upload response received:', response.data);
        
        if (response.data.success) {
          console.log('Processing successful, adapting table to data...');
          const selectedTemplate = getSelectedTemplate();
          const useTemplate = !!(selectedTemplate && selectedTemplate.headers);
          let headers, rows;
          
          if (useTemplate) {
            console.log('Using template headers from:', selectedTemplate.name);
            headers = [...selectedTemplate.headers];
            rows = await buildRowsFromTemplate(response.data.data, headers, selectedTemplate);
          } else {
            console.log('No template selected, generating headers from data');
            headers = await buildHeadersFromProcessed(response.data.data);
            rows = await buildRowsFromProcessed(response.data.data, headers);
          }
          // When new uploads are processed, ensure we map to the new data rather than showing any saved template rows
          try { window.previewingTemplateRows = false; } catch (_) {}
          try { localStorage.removeItem('excelEditorData'); } catch(_) {}
          localStorage.setItem('excelEditorData', JSON.stringify({ headers, rows }));
          const hint = document.getElementById('excelEditorHint');
          if (hint) hint.classList.remove('hidden');
          await adaptTableToData(response.data.data, useTemplate);
          showStatus('Files processed successfully', 'success');
        }
      } catch (error) {
        console.error('Error processing files:', error);
        showStatus('Error processing files: ' + error.message, 'error');
      }
    }
    // Build headers and rows for Excel editor from processed structure
    async function buildHeadersFromProcessed(data) {
      const all = new Set(['Department']);
      (data.departments || []).forEach(dept => {
        const metrics = (data.metrics || {})[dept] || {};
        Object.keys(metrics).forEach(k => { if (k !== 'Department') all.add(k); });
        const emp = data.activities?.employerEngagement?.[dept] || {};
        Object.keys(emp).forEach(k => all.add(`${k} (Employer Engagement)`));
        const enr = data.activities?.enrichment?.[dept] || {};
        Object.keys(enr).forEach(k => all.add(`${k} (Enrichment)`));
      });
      return Array.from(all);
    }

    async function buildRowsFromProcessed(data, headers) {
      return (data.departments || []).map(dept => {
        const row = [dept];
        const metrics = (data.metrics || {})[dept] || {};
        const emp = data.activities?.employerEngagement?.[dept] || {};
        const enr = data.activities?.enrichment?.[dept] || {};
        headers.slice(1).forEach(h => {
          let val = '';
          if (h.endsWith(' (Employer Engagement)')) {
            const originalKey = h.replace(' (Employer Engagement)', '');
            val = emp[originalKey] ?? '';
          } else if (h.endsWith(' (Enrichment)')) {
            const originalKey = h.replace(' (Enrichment)', '');
            val = enr[originalKey] ?? '';
          } else {
            val = metrics[h] ?? '';
          }
          row.push(val);
        });
        return row;
      })();

      // Bind edit toolbar interactions
      try {
        const editToggleBtn = document.getElementById('editToggleBtn');
        if (editToggleBtn) {
          console.log('=== Initializing editing toolbar listeners ===');
          initializeEditing();
        } else {
          console.warn('Edit toggle button not found at setup; will initialize after first render');
        }
      } catch (e) { console.warn('Failed to initialize editing toolbar:', e?.message || e); }
    }

    // Build rows using template structure - maps data to template headers
    async function buildRowsFromTemplate(data, templateHeaders, selectedTemplate) {
      console.log('Building rows from template:', selectedTemplate.name);
      console.log('Template headers:', templateHeaders);
      
      const templateMode = getTemplateMode();
      console.log('Template mode:', templateMode);
      
      return (data.departments || []).map(dept => {
        const row = [dept]; // First column is always Department
        // Use the same resolver as the main table rendering to ensure consistent mapping
        templateHeaders.slice(1).forEach(templateHeader => {
          const val = resolveCellValue(templateHeader, dept, data);
          row.push(val);
        });
        return row;
      });
    }

    // Build rows using original headers from uploaded files (for template creation)
    async function buildRowsFromOriginalHeaders(data, originalHeaders) {
      console.log('Building rows from original headers:', originalHeaders);
      console.log('Available departments:', data.departments);
      
      return (data.departments || []).map(dept => {
        const row = [dept]; // First column is always Department
        const metrics = (data.metrics || {})[dept] || {};
        const emp = data.activities?.employerEngagement?.[dept] || {};
        const enr = data.activities?.enrichment?.[dept] || {};
        
        // Combine all data sources
        const allData = { ...metrics, ...emp, ...enr };
        console.log(`\n=== DEPARTMENT: ${dept} ===`);
        console.log(`Available processed keys:`, Object.keys(allData));
        console.log(`Original headers to match:`, originalHeaders);
        
        // For each original header, try to find corresponding data
        originalHeaders.slice(1).forEach(originalHeader => {
          let value = '';
          
          // Strategy 1: Direct exact match
          if (allData[originalHeader] !== undefined) {
            value = allData[originalHeader];
            console.log(`Direct match for "${originalHeader}": ${value}`);
          } else {
            // Strategy 2: Remove content type suffixes and compare
            let foundKey = Object.keys(allData).find(key => {
              const cleanKey = key.replace(/\s*\([^)]*\)\s*$/g, '').trim();
              return cleanKey === originalHeader.trim();
            });
            
            if (!foundKey) {
              // Strategy 3: Fuzzy matching - check if processed key contains original header
              foundKey = Object.keys(allData).find(key => {
                const cleanKey = key.replace(/\s*\([^)]*\)\s*$/g, '').trim().toLowerCase();
                const cleanOriginal = originalHeader.trim().toLowerCase();
                return cleanKey.includes(cleanOriginal) || cleanOriginal.includes(cleanKey);
              });
            }
            
            if (!foundKey) {
              // Strategy 4: Very fuzzy matching - partial word matches
              foundKey = Object.keys(allData).find(key => {
                const keyWords = key.toLowerCase().split(/[\s\(\)\-\_]+/).filter(w => w.length > 2);
                const origWords = originalHeader.toLowerCase().split(/[\s\(\)\-\_]+/).filter(w => w.length > 2);
                return keyWords.some(kw => origWords.some(ow => kw.includes(ow) || ow.includes(kw)));
              });
            }
            
            if (foundKey) {
              value = allData[foundKey];
              console.log(`Matched original header "${originalHeader}" to processed "${foundKey}": ${value}`);
            } else {
              console.log(`No match found for original header: "${originalHeader}"`);
              // For template creation, we still want the column to exist even if empty
              value = '';
            }
          }
          
          row.push(value);
        });
        
        return row;
      });
    }
    
    // Process template - follows same workflow as processFiles (just shows preview)
    async function processTemplate() {
      console.log('=== processTemplate called ===');
      console.log('=== THIS FUNCTION SHOULD ONLY SHOW PREVIEW, NOT CREATE TEMPLATES ===');
      
      // Clear any existing data to ensure fresh start
      console.log('üßπ Clearing existing table data for fresh template processing...');
      tableHeaders = [];
      tableData = [];
      previousReportData = null;
      window.useOriginalHeaders = false; // Reset this flag
      
      // Clear localStorage cache
      try { 
        localStorage.removeItem('excelEditorData'); 
        console.log('‚úÖ Cleared excelEditorData cache');
      } catch(e) { 
        console.warn('‚ö†Ô∏è Could not clear excelEditorData:', e.message); 
      }
      
      const templateFileInput = document.getElementById('templateFileInput');
      
      if (!templateFileInput || !templateFileInput.files.length) {
        showStatus('Please select files to process', 'error');
        return;
      }
      
      console.log(`Processing files for template preview ONLY from ${templateFileInput.files.length} files:`, Array.from(templateFileInput.files).map(f => f.name));
      console.log('=== NO TEMPLATE WILL BE CREATED AUTOMATICALLY ===');
      
      // Get file type selections for template preview
      const templateFileTypeSelections = getTemplateFileTypeSelections();
      if (!templateFileTypeSelections) {
        showStatus('Please select file types for all uploaded files', 'error');
        return;
      }
      
      const formData = new FormData();
      for (const file of templateFileInput.files) {
        formData.append('files', file);
        console.log(`Added file to FormData: ${file.name}`);
      }
      
      // Add file type selections to form data
      formData.append('fileTypes', JSON.stringify(templateFileTypeSelections));
      
      showStatus('Processing files...', 'info');
      
      try {
        console.log('Sending template preview request to NEW RAW endpoint...');
        const response = await axios.post('/api/template-preview', formData);
        console.log('Template preview response received:', response.data);
        
        if (response.data.success) {
          console.log('Template preview successful, using RAW data...');
          console.log('RAW TEMPLATE DATA:', response.data.data);
          
          // For template processing, use RAW data directly from new endpoint
          console.log('Process Template: Using RAW data from template-preview endpoint');
          
          // Extract raw headers and rows directly - NO processing needed!
          // Prefer a faithful reconstruction if rawGrid is present
          const rawGrid = response.data.data.rawGrid || [];
          let headers = response.data.data.headers || [];
          let rows = response.data.data.rows || [];

          // If we have a raw grid, reconstruct headers/rows exactly
          if (Array.isArray(rawGrid) && rawGrid.length) {
            // Find header row the same way as backend chose it
            let headerRowIndex = 0;
            let maxHeaderCells = 0;
            for (let i = 0; i < Math.min(5, rawGrid.length); i++) {
              const row = rawGrid[i] || [];
              const nonEmptyCells = row.filter(c => c !== null && c !== undefined && String(c).trim() !== '').length;
              if (nonEmptyCells > maxHeaderCells) {
                maxHeaderCells = nonEmptyCells;
                headerRowIndex = i;
              }
            }
            headers = (rawGrid[headerRowIndex] || []).map(h => h === null || h === undefined ? '' : String(h));
            rows = rawGrid.slice(headerRowIndex + 1).map(r => {
              const row = Array.from({ length: headers.length }, (_, idx) => r[idx] ?? '');
              return row;
            });
          }
          
          // Extract header colors from response
          const headerColors = response.data.data.headerColors || [];
          
          console.log('‚úÖ RAW Headers from upload:', headers);
          console.log('‚úÖ RAW Header Colors:', headerColors);
          console.log('‚úÖ RAW Headers length:', headers.length);
          console.log('‚úÖ RAW Headers type:', typeof headers);
          console.log('‚úÖ RAW Headers detailed:', JSON.stringify(headers, null, 2));
          console.log('‚úÖ RAW Rows count:', rows.length);
          console.log('‚úÖ Sample row:', rows[0]);
          console.log('‚úÖ Sample row length:', rows[0] ? rows[0].length : 'N/A');
          console.log('‚úÖ Sample row detailed:', rows[0] ? JSON.stringify(rows[0], null, 2) : 'N/A');
          
          // Validate that we have proper data structure
          if (headers.length === 0) {
            console.error('‚ùå No headers found in template data!');
            showStatus('No column headers found in the uploaded file. Please check the file format.', 'error');
            return;
          }
          
          if (rows.length === 0) {
            console.error('‚ùå No data rows found in template data!');
            showStatus('No data rows found in the uploaded file. Please check the file format.', 'error');
            return;
          }
          
          // Set flags to render strictly as uploaded but with section-based coloring
          window.useOriginalHeaders = false; // Use section-based coloring instead of Excel colors
          window.strictTemplateMode = true;
          
          // Store in global variables for table rendering
          tableHeaders = [...headers];
          tableData = [...rows];
          tableHeaderColors = [...headerColors]; // Store colors for template rendering
          
          // Store headerFileMap and fileInfo for section-based coloring
          if (response.data.data.headerFileMap) {
            headerFileMap = response.data.data.headerFileMap;
            window.headerFileMap = response.data.data.headerFileMap; // Also set on window
            console.log('Template preview headerFileMap:', headerFileMap);
            console.log('Template preview window.headerFileMap:', window.headerFileMap);
          }
          
          if (response.data.data.fileInfo) {
            window.fileInfo = response.data.data.fileInfo;
            console.log('Template preview fileInfo:', window.fileInfo);
            // Overlay saved selections for consistency
            try {
              if (window.__fileLevelSelections && Array.isArray(window.fileInfo)) {
                Object.keys(window.__fileLevelSelections).forEach(k => {
                  const idx = parseInt(k); const sel = window.__fileLevelSelections[k];
                  if (!isNaN(idx) && window.fileInfo[idx]) {
                    if (sel && sel.color) window.fileInfo[idx].customColor = sel.color;
                    // Preserve activity types; only override when not an activity or when types match
                    try {
                      const origType = (window.fileInfo[idx].contentType || '').toLowerCase();
                      const newType = (sel && sel.type) ? String(sel.type).toLowerCase() : '';
                      const isActivity = origType === 'enrichment' || origType === 'employment' || origType === 'employer';
                      const matchesActivity = (isActivity && (newType === origType || (origType === 'employment' && newType === 'employer')));
                      if (!isActivity) {
                        if (newType) window.fileInfo[idx].contentType = newType;
                      } else if (matchesActivity) {
                        window.fileInfo[idx].contentType = (newType === 'employer') ? 'employment' : origType;
                      }
                    } catch(_) {}
                  }
                });
              }
            } catch(_) {}
          }
          
          // Cache data for Excel editor
          try { localStorage.removeItem('excelEditorData'); } catch(_) {}
          localStorage.setItem('excelEditorData', JSON.stringify({ headers, rows }));
          const hint = document.getElementById('excelEditorHint');
          if (hint) hint.classList.remove('hidden');
          
          // Render the table directly with raw data (skip adaptTableToData for templates)
          console.log('Rendering table with raw template data...');
          renderTable();
          // Auto-enable edit mode after initial render
          try {
            editMode = true;
            const editControls = document.getElementById('editControls');
            const editToggleBtn = document.getElementById('editToggleBtn');
            if (editControls) editControls.classList.remove('hidden');
            if (editToggleBtn) editToggleBtn.textContent = '‚úÖ Editing On';
            renderTable();
          } catch(_) {}
          
          showStatus('Files processed successfully', 'success');
          
        } else {
          showStatus('Failed to process files: ' + (response.data.error || 'Unknown error'), 'error');
        }
      } catch (error) {
        console.error('Error processing files:', error);
        let errorMessage = 'File processing failed';
        if (error.response && error.response.data && error.response.data.error) {
          errorMessage += ': ' + error.response.data.error;
        } else {
          errorMessage += ': ' + error.message;
        }
        showStatus(errorMessage, 'error');
      }
    }
    
    // Test activity processing
    async function testActivityProcessing() {
      showStatus('Testing activity processing...', 'info');
      
      // Create test data with proper activity structure
      const testData = {
        departments: ['Test Department 1', 'Test Department 2'],
        metrics: {},
        activities: {
          employerEngagement: {
            'Test Department 1': {
              'Students with Activities (Employer Engagement)': 50,
              'Total Activities (Employer Engagement)': 200,
              '% Students with Activities (Employer Engagement)': 0.85,
              'Total Activity Hours (Employer Engagement)': 1500
            },
            'Test Department 2': {
              'Students with Activities (Employer Engagement)': 75,
              'Total Activities (Employer Engagement)': 300,
              '% Students with Activities (Employer Engagement)': 0.92,
              'Total Activity Hours (Employer Engagement)': 2200
            }
          },
          enrichment: {
            'Test Department 1': {
              'Students with Activities (Enrichment)': 30,
              'Total Activities (Enrichment)': 150,
              '% Students with Activities (Enrichment)': 0.75,
              'Total Activity Hours (Enrichment)': 800
            },
            'Test Department 2': {
              'Students with Activities (Enrichment)': 45,
              'Total Activities (Enrichment)': 180,
              '% Students with Activities (Enrichment)': 0.88,
              'Total Activity Hours (Enrichment)': 1200
            }
          }
        }
      };
      
      console.log('Test data created:', testData);
      await adaptTableToData(testData);
      showStatus('Test activity processing completed', 'success');
    }


    // Table functions
    async function adaptTableToData(data, useTemplateForPreview = false) {
      console.log('=== adaptTableToData called ===');
      console.log('Data received:', data);
      // Persist the most recent processed payload for template remapping on selection
      try { window.latestProcessedData = data; } catch (_) {}
      if (typeof window.previewingTemplateRows === 'undefined') { window.previewingTemplateRows = false; }
      // Store the headerFileMap and fileInfo for color assignment
      const __selectedTpl = useTemplateForPreview ? getSelectedTemplate() : null;
      if (useTemplateForPreview && __selectedTpl) {
        // Merge template map with fresh data map so new typed variants (e.g. activities-combined) resolve
        const tplMap = (__selectedTpl.headerFileMap && typeof __selectedTpl.headerFileMap === 'object') ? __selectedTpl.headerFileMap : {};
        const dataMap = (data && data.headerFileMap && typeof data.headerFileMap === 'object') ? data.headerFileMap : {};
        headerFileMap = { ...tplMap, ...dataMap };
        window.headerFileMap = { ...headerFileMap };
        console.log('Merged template headerFileMap with data.headerFileMap');
      } else if (data && data.headerFileMap) {
        headerFileMap = data.headerFileMap;
        window.headerFileMap = data.headerFileMap; // Also set on window
        console.log('Header file mapping:', headerFileMap);
        console.log('Window header file mapping:', window.headerFileMap);
      } else {
        headerFileMap = {};
        window.headerFileMap = {};
        console.log('No headerFileMap provided, using fallback coloring');
      }
      
      // Prefer current run's fileInfo to ensure up-to-date content types (e.g., activities-combined)
      if (data && data.fileInfo) {
        window.fileInfo = data.fileInfo;
        console.log('File info received (current run):', window.fileInfo);
        globalThis.fileInfoData = data.fileInfo;
      } else if (useTemplateForPreview && __selectedTpl && Array.isArray(__selectedTpl.fileInfo)) {
        window.fileInfo = [...__selectedTpl.fileInfo];
        console.log('Using template fileInfo for colouring (fallback)');
      }
      // Overlay any saved selections (type/color) to persist user-chosen colours across renders
      try {
        if (window.__fileLevelSelections && Array.isArray(window.fileInfo)) {
          Object.keys(window.__fileLevelSelections).forEach(k => {
            const idx = parseInt(k);
            const sel = window.__fileLevelSelections[k];
            if (!isNaN(idx) && window.fileInfo[idx]) {
              if (sel && sel.color) window.fileInfo[idx].customColor = sel.color;
              // Preserve detected activity types; only override when not an activity or when types match
              try {
                const origType = (window.fileInfo[idx].contentType || '').toLowerCase();
                const newType = (sel && sel.type) ? String(sel.type).toLowerCase() : '';
                const isActivity = origType === 'enrichment' || origType === 'employment' || origType === 'employer';
                const matchesActivity = (isActivity && (newType === origType || (origType === 'employment' && newType === 'employer')));
                if (!isActivity) {
                  if (newType) window.fileInfo[idx].contentType = newType;
                } else if (matchesActivity) {
                  // normalise employer -> employment
                  window.fileInfo[idx].contentType = (newType === 'employer') ? 'employment' : origType;
                }
              } catch(_) {}
            }
          });
        }
      } catch (_) { console.warn('Failed to overlay saved file selections'); }
      // Render legend for file colours if container exists
      try {
        const legend = document.getElementById('fileLegend');
        if (legend && Array.isArray(window.fileInfo)) {
          legend.innerHTML = window.fileInfo.map((fi, idx) => {
            const c = (fi && fi.customColor) ? fi.customColor : ['#1d4ed8', '#9333ea', '#059669', '#ea580c', '#dc2626', '#0ea5e9', '#f59e0b'][idx % 7];
            const name = (fi && (fi.originalName || fi.filename)) ? (fi.originalName || fi.filename) : `File ${idx + 1}`;
            return `<span style="display:inline-flex;align-items:center;margin-right:12px;margin-bottom:6px;">
              <span style="display:inline-block;width:10px;height:10px;background:${c};border-radius:2px;margin-right:6px;"></span>
              <span style="font-size:12px;color:#374151;">${name}</span>
            </span>`;
          }).join('');
        }
      } catch (_) {}
      
      if (data.departments) {
        const selectedTemplate = useTemplateForPreview ? getSelectedTemplate() : null;
        const templateMode = getTemplateMode();
        console.log('Selected template (for preview):', useTemplateForPreview ? selectedTemplate : null);

        // If a template is selected and we already computed tableHeaders/tableData
        // (via buildRowsFromTemplate in processFiles), do NOT rebuild them here.
        // Simply render with the existing rows to avoid losing user-edited template structure.
        if (
          selectedTemplate &&
          Array.isArray(tableHeaders) && tableHeaders.length > 0 &&
          Array.isArray(tableData) && tableData.length > 0 &&
          window.previewingTemplateRows === true
        ) {
          console.log('Using precomputed template headers and rows; adjusting headers for department-like duplicates');
          // Remove department-like duplicates (e.g., Curriculum Area) if Department exists
          try {
            const deptLike = new Set(['department','dept','program','course','category','curriculum area','curriculum','subject area','subject','faculty','school','team']);
            const hasDept = Array.isArray(tableHeaders) && tableHeaders.some(h => String(h || '').trim().toLowerCase() === 'department');
            if (hasDept && Array.isArray(tableHeaders)) {
              tableHeaders = ['Department', ...tableHeaders.filter((h, idx) => {
                if (idx === 0) return false; // will re-add Department at start
                const low = String(h || '').trim().toLowerCase();
                return !deptLike.has(low);
              })];
            }
          } catch (_) { console.warn('Failed to strip department-like duplicate headers in precompute path'); }

          // Ensure headerFileMap and fileInfo are available from the selected template for coloring
          try {
            // Helper to synthesize fileInfo from headerFileMap
            function synthesizeFileInfoFromMap(hmap) {
              const indices = new Set();
              Object.values(hmap || {}).forEach(v => { if (typeof v === 'number') indices.add(v); });
              const maxIdx = indices.size ? Math.max(...Array.from(indices)) : -1;
              const out = [];
              for (let i = 0; i <= maxIdx; i++) {
                out.push({ originalName: `File ${i + 1}` , filename: `file_${i+1}` , customColor: undefined, label: `File ${i + 1}` });
              }
              return out;
            }
            if (selectedTemplate.headerFileMap && typeof selectedTemplate.headerFileMap === 'object') {
              window.headerFileMap = { ...selectedTemplate.headerFileMap };
            } else {
              window.headerFileMap = {};
            }
            headerFileMap = window.headerFileMap;
            if (Array.isArray(selectedTemplate.fileInfo)) {
              window.fileInfo = [...selectedTemplate.fileInfo];
            } else if (Object.keys(window.headerFileMap).length > 0) {
              window.fileInfo = synthesizeFileInfoFromMap(window.headerFileMap);
            } else {
              window.fileInfo = [];
            }
            window.strictTemplateMode = true;
            window.useOriginalHeaders = false;
          } catch (e) { console.warn('Failed to ensure template metadata in adaptTableToData:', e?.message || e); }
          try { renderTable(); } catch (e) { console.warn('Render after precompute failed:', e?.message || e); }
          return;
        }
        
        if (selectedTemplate && selectedTemplate.headers) {
          console.log('Applying template:', selectedTemplate.name);
          
          // Start with template headers and structure
          tableHeaders = [...selectedTemplate.headers];
          // Remove department-like duplicates (e.g., Curriculum Area) if Department is present
          try {
            const deptLike = new Set(['department','dept','program','course','category','curriculum area','curriculum','subject area','subject','faculty','school','team']);
            const hasDept = tableHeaders.some(h => String(h || '').trim().toLowerCase() === 'department');
            if (hasDept) {
              tableHeaders = ['Department', ...tableHeaders.filter((h, idx) => {
                if (idx === 0) return false; // will re-add Department at start
                const low = String(h || '').trim().toLowerCase();
                return !deptLike.has(low);
              })];
            }
          } catch(_) {}
          console.log('Template headers:', tableHeaders);
          
          // Build lookup for new data including activities
          const newDataLookup = {};
          data.departments.forEach(dept => {
            newDataLookup[dept] = data.metrics[dept] || {};
          });
          
          // Add activity metrics
          console.log('Processing activity metrics...');
          data.departments.forEach(dept => {
            const employerEngagement = data.activities?.employerEngagement?.[dept] || {};
            const enrichment = data.activities?.enrichment?.[dept] || {};
            
            console.log(`Department ${dept} - Employer Engagement keys:`, Object.keys(employerEngagement));
            console.log(`Department ${dept} - Enrichment keys:`, Object.keys(enrichment));
            
            Object.keys(employerEngagement).forEach(key => {
              newDataLookup[dept][key] = employerEngagement[key];
            });
            
            Object.keys(enrichment).forEach(key => {
              newDataLookup[dept][key] = enrichment[key];
            });
          });
          
          // Removed erroneous references to undefined `new DataLookup` which caused runtime errors
          
          // Build a map of activity header -> type using actual data to aid classification
          try {
            const employerSet = new Set();
            const enrichmentSet = new Set();
            data.departments.forEach(dept => {
              const employerEngagement = data.activities?.employerEngagement?.[dept] || {};
              const enrichment = data.activities?.enrichment?.[dept] || {};
              Object.keys(employerEngagement).forEach(h => employerSet.add(h));
              Object.keys(enrichment).forEach(h => enrichmentSet.add(h));
            });
            window.activityHeaderTypeMap = {};
            employerSet.forEach(h => {
              window.activityHeaderTypeMap[h] = 'employment';
              window.activityHeaderTypeMap[`${h} (Employer Engagement)`] = 'employment';
            });
            enrichmentSet.forEach(h => {
              window.activityHeaderTypeMap[h] = 'enrichment';
              window.activityHeaderTypeMap[`${h} (Enrichment)`] = 'enrichment';
            });
            console.log('Built activityHeaderTypeMap:', window.activityHeaderTypeMap);
          } catch (e) {
            console.warn('Failed to build activityHeaderTypeMap:', e?.message || e);
          }
          
          // IMPORTANT: For template runs, keep the exact header order from the saved template.
          // Do not reorganize by section or file. This preserves the template's column order.
          window.strictTemplateMode = true;
          // tableHeaders already set from selectedTemplate.headers above
          
          // Do NOT create a fallback headerFileMap when applying a saved template.
          // If the saved template lacks headerFileMap, prefer section-based coloring
          // rather than inventing per-file colors which can be misleading.
          if (!window.strictTemplateMode) {
            if (Object.keys(headerFileMap).length === 0) {
              console.log('Creating fallback headerFileMap (non-template mode)');
              tableHeaders.forEach((header, index) => {
                if (header !== 'Department' && !headerFileMap.hasOwnProperty(header)) {
                  headerFileMap[header] = Math.floor(index / 5); // Distribute across files
                }
              });
            }
          }
          
          console.log('Organized headers:', tableHeaders);
          console.log('Final headerFileMap:', headerFileMap);
          
          // Build table data
          // Use template's saved rows (first column = Department) to control which rows appear and in what order
          let departmentsToUse = Array.isArray(data.departments) ? [...data.departments] : [];
          try {
            const selTpl = getSelectedTemplate ? getSelectedTemplate() : null;
            const tplRows = selTpl && Array.isArray(selTpl.tableData) ? selTpl.tableData : null;
            if (tplRows && tplRows.length > 0) {
              const desired = tplRows
                .map(r => (Array.isArray(r) ? r[0] : null))
                .filter(v => typeof v === 'string' && v.length > 0);
              const available = new Set(data.departments || []);
              // Keep only departments present in current data, preserve template order
              departmentsToUse = desired.filter(d => available.has(d));
            }
          } catch (_) {}

          tableData = departmentsToUse.map(dept => {
            const row = [dept];
            tableHeaders.slice(1).forEach(header => {
              row.push(resolveCellValue(header, dept, data));
            });
            return row;
          });
          
          console.log('Table data built:', tableData.length, 'rows');
        } else {
          console.log('adaptTableToData: No template selected, building from data with strict original file order');

          // Build headers strictly preserving per-file original order
          tableHeaders = buildHeadersPreservingOriginalFileOrder(data);

          // Build a map of activity header -> type using actual data to aid classification (for coloring only)
          try {
            const employerSet = new Set();
            const enrichmentSet = new Set();
            data.departments.forEach(dept => {
              const employerEngagement = data.activities?.employerEngagement?.[dept] || {};
              const enrichment = data.activities?.enrichment?.[dept] || {};
              Object.keys(employerEngagement).forEach(h => employerSet.add(h));
              Object.keys(enrichment).forEach(h => enrichmentSet.add(h));
            });
            window.activityHeaderTypeMap = {};
            employerSet.forEach(h => { window.activityHeaderTypeMap[h] = 'employment'; });
            enrichmentSet.forEach(h => { window.activityHeaderTypeMap[h] = 'enrichment'; });
            console.log('Built activityHeaderTypeMap:', window.activityHeaderTypeMap);
          } catch (e) {
            console.warn('Failed to build activityHeaderTypeMap:', e?.message || e);
          }

          console.log('Headers (original order):', tableHeaders);
          console.log('Final headerFileMap:', headerFileMap);

          // Build table data following the headers as-is
          tableData = data.departments.map(dept => {
            const row = [dept];
            tableHeaders.slice(1).forEach(header => {
              row.push(resolveCellValue(header, dept, data));
            });
            return row;
          });

          console.log('Table data built:', tableData.length, 'rows');
        }
        
        console.log('About to call renderTable()...');
        try {
          renderTable();
          console.log('renderTable() completed successfully');
        } catch (error) {
          console.error('Error in renderTable():', error);
        }
        
        if (currentCollegeId) {
          await loadPreviousReportData(currentCollegeId);
          renderTable();
        }
      } else {
        console.error('No departments found in data:', data);
      }
    }

    // Organize headers by section for proper grouping
    function organizeHeadersBySection(headers) {
      const sections = {
        department: [],
        students: [],
        placements: [],
        activities: [],
        assessments: [],
        careers: [],
        other: []
      };
      
      // Helper: department-like header detection (synonyms)
      const isDeptLike = (s) => {
        const x = String(s || '').trim().toLowerCase();
        return x === 'department' ||
               x === 'dept' ||
               x === 'program' ||
               x === 'course' ||
               x === 'category' ||
               x === 'curriculum area' ||
               x === 'curriculum' ||
               x === 'subject area' ||
               x === 'subject' ||
               x === 'faculty' ||
               x === 'school' ||
               x === 'team';
      };

      headers.forEach(header => {
        // Skip purely numeric headers like "1", "2", etc., but allow headers containing digits (e.g., "[data1]")
        if (!header) {
          return;
        }
        const hStr = header.toString().trim();
        if (/^[0-9]+$/.test(hStr)) {
          return;
        }
        
        const h = header.toString();
        const hl = h.toLowerCase();
        const isDept = h === 'Department' || isDeptLike(h);
        
        // Data-driven hint from built map
        const hintedType = (typeof window !== 'undefined' && window.activityHeaderTypeMap) ? window.activityHeaderTypeMap[h] : null;
        if (isDept) {
          sections.department.push(h);
          return;
        }
        if (hintedType === 'employment' || hintedType === 'enrichment') {
          sections.activities.push(h);
          return;
        }
        
        // Activity categorisation (string-based fallback)
        const isEmployerActivity = h.includes('(Employer Engagement)') ||
                                   (hl.includes('employer') && (hl.includes('engagement') || hl.includes('activity') || hl.includes('activities')));
        const isEnrichmentActivity = h.includes('(Enrichment)') || hl.includes('enrichment');
        
        if (isEmployerActivity) {
          sections.activities.push(h);
        } else if (isEnrichmentActivity) {
          sections.activities.push(h);
        } else if (hl.includes('placement') || hl.includes('placed') || hl.includes('student confirmed') || hl.includes('employer confirmed')) {
          sections.placements.push(h);
        } else if (hl.includes('assessment') || hl.includes('score')) {
          sections.assessments.push(h);
        } else if (hl.includes('career') || hl.includes('job profile') || hl.includes('quiz') || hl.includes('mapped')) {
          sections.careers.push(h);
        } else if (hl.includes('student')) {
          sections.students.push(h);
        } else if (hl.includes('activity') || hl.includes('activities') || hl.includes('hours')) {
          sections.activities.push(h);
        } else {
          sections.other.push(h);
        }
      });
      
      return [
        ...sections.department,
        ...sections.activities,
        ...sections.placements,
        ...sections.assessments,
        ...sections.careers,
        ...sections.students,
        ...sections.other
      ];
    }

    // Reorder headers primarily by file upload order while keeping Department first.
    // This respects the user's upload order using headerFileMap -> file indices.
    function reorderHeadersByFile(headers) {
      try {
        if (!headers || headers.length === 0) return headers;
        const deptFirst = headers.filter(h => h === 'Department');
        const rest = headers.filter(h => h !== 'Department');

        // Build buckets by file index while preserving original header order
        const buckets = new Map(); // fileIdx -> array of headers
        const unknown = []; // headers without mapping

        const getIdx = (h) => {
          // Try exact, then strip +/- and map
          let key = h;
          if (key.endsWith(' +/-')) key = key.slice(0, -4);
          // Attempt a few normalisations similar to renderTable
          const normEmployer = key.replace(/ \(Employer Engagement\)$/i, ' (employer)');
          const normEnrichment = normEmployer.replace(/ \(Enrichment\)$/i, ' (enrichment)');

          // Use global headerFileMap when available
          const map = (typeof window !== 'undefined' && window.headerFileMap) ? window.headerFileMap : (typeof headerFileMap !== 'undefined' ? headerFileMap : null);
          if (!map) return undefined;

          const idx = map[key] ?? map[normEnrichment] ?? map[normEmployer] ?? map[key.replace(/ \(.*\)$/,'')];
          return idx;
        };

        rest.forEach(h => {
          const idx = getIdx(h);
          if (idx === undefined) {
            unknown.push(h);
          } else {
            if (!buckets.has(idx)) buckets.set(idx, []);
            buckets.get(idx).push(h);
          }
        });

        // Assemble result by ascending file index, then any unknowns at the end
        const ordered = [];
        Array.from(buckets.keys()).sort((a,b) => a - b).forEach(idx => {
          ordered.push(...buckets.get(idx));
        });
        ordered.push(...unknown);

        return [...deptFirst, ...ordered];
      } catch (e) {
        console.warn('reorderHeadersByFile failed, returning original order:', e?.message || e);
        return headers;
      }
    }

    // Build headers preserving the strict original per-file column order
    // Uses processed data: originalHeaders (first-seen order), headerFileMap (header -> fileIdx), and fileInfo (upload order)
    function buildHeadersPreservingOriginalFileOrder(data) {
      try {
        const out = ['Department'];
        const seen = new Set(out);

        const hasFiles = Array.isArray(data?.fileInfo) && data.fileInfo.length > 0;
        const hasMap = data && data.headerFileMap && typeof data.headerFileMap === 'object';
        const hasOriginal = Array.isArray(data?.originalHeaders) && data.originalHeaders.length > 0;

        if (!hasFiles || !hasMap) {
          // Fallback to current behavior if required structures are missing
          return out;
        }

        // Helper to map content type to activity suffix expected by the front-end rows builder
        function activitySuffixForType(t) {
          const tt = String(t || '').toLowerCase();
          if (tt === 'employment' || tt === 'employer') return ' (Employer Engagement)';
          if (tt === 'enrichment') return ' (Enrichment)';
          return '';
        }

        // Iterate files in upload order
        for (let fileIdx = 0; fileIdx < data.fileInfo.length; fileIdx++) {
          const info = data.fileInfo[fileIdx] || {};
          const suffix = activitySuffixForType(info.contentType);

          if (hasOriginal) {
            // Walk original headers in their recorded first-seen order
            for (const h of data.originalHeaders) {
              if (!h) continue;
              const hs = String(h).trim();
              const hsLower = hs.toLowerCase();
              const isDeptLike = (
                hsLower === 'department' || hsLower === 'dept' || hsLower === 'program' || hsLower === 'course' ||
                hsLower === 'category' || hsLower === 'curriculum area' || hsLower === 'curriculum' ||
                hsLower === 'subject area' || hsLower === 'subject' || hsLower === 'faculty' ||
                hsLower === 'school' || hsLower === 'team'
              );
              if (!hs || isDeptLike || /^[0-9]+$/.test(hs)) continue;
              // Prefer file-specific mapping to avoid collisions across files
              const label = (data.fileInfo[fileIdx] && (data.fileInfo[fileIdx].label || data.fileInfo[fileIdx].originalName || data.fileInfo[fileIdx].filename))
                ? (data.fileInfo[fileIdx].label || data.fileInfo[fileIdx].originalName || data.fileInfo[fileIdx].filename)
                : null;
              let type = (data.fileInfo[fileIdx] && data.fileInfo[fileIdx].contentType) ? String(data.fileInfo[fileIdx].contentType).toLowerCase() : '';
              if (type === 'employer') type = 'employment';

              // Build candidate keys that DataImporter added to headerFileMap
              const typed = type ? `${hs} (${type})` : null;
              const employerSyn = `${hs} (employer engagement)`;
              const employerActSyn = `${hs} (employer activity)`;
              const enrichSyn = `${hs} (enrichment)`;
              const candidates = [
                // Most specific: typed + label
                (label && typed) ? `${typed} [${label}]` : null,
                // Labelled without type
                label ? `${hs} [${label}]` : null,
                // Type-only variations
                typed,
                // Synonyms for activities
                (type === 'employment') ? employerSyn : null,
                (type === 'employment') ? employerActSyn : null,
                (type === 'enrichment') ? enrichSyn : null,
                // Raw header last
                hs
              ].filter(Boolean);

              let belongsToThisFile = false;
              for (const key of candidates) {
                if (data.headerFileMap[key] === fileIdx) { belongsToThisFile = true; break; }
              }

              if (belongsToThisFile) {
                const labelOut = (data.fileInfo[fileIdx] && (data.fileInfo[fileIdx].label || data.fileInfo[fileIdx].originalName || data.fileInfo[fileIdx].filename))
                  ? (data.fileInfo[fileIdx].label || data.fileInfo[fileIdx].originalName || data.fileInfo[fileIdx].filename)
                  : null;
                const baseOut = suffix ? `${hs}${suffix}` : hs;
                const headerOut = labelOut ? `${baseOut} [${labelOut}]` : baseOut;
                if (!seen.has(headerOut)) {
                  out.push(headerOut);
                  seen.add(headerOut);
                }
              }
            }
          } else {
            // Fallback: derive from headerFileMap keys belonging to this file
            const keys = Object.keys(data.headerFileMap)
              .filter(k => data.headerFileMap[k] === fileIdx)
              // Prefer base headers without [Label] and without any typed duplicates
              .map(k => String(k).replace(/\s*\[[^\]]+\]\s*$/, ''));
            // Maintain stable order by first appearance
            const orderedUnique = [];
            const added = new Set();
            for (const k of keys) {
              const base = k;
              if (!added.has(base)) {
                added.add(base);
                orderedUnique.push(base);
              }
            }
            for (const base of orderedUnique) {
              if (!base || base.toLowerCase() === 'department' || /^[0-9]+$/.test(base)) continue;
              const headerOut = suffix ? `${base}${suffix}` : base;
              if (!seen.has(headerOut)) {
                out.push(headerOut);
                seen.add(headerOut);
              }
            }
          }
        }

        return out;
      } catch (e) {
        console.warn('buildHeadersPreservingOriginalFileOrder failed:', e?.message || e);
        return ['Department'];
      }
    }

    // Create section headers based on content type
    function createSectionHeaders(headers) {
      const sections = [];
      let currentContentType = null;
      let currentCount = 0;
      
      headers.forEach((header, index) => {
        const isChangeColumn = header.endsWith(' +/-');
        const originalHeader = isChangeColumn ? header.replace(' +/-', '') : header;
        
        // Skip headers that are "1" or contain "1"
        if (!originalHeader || originalHeader.toString().toLowerCase().includes('1')) {
          return;
        }
        
        // Get content type for this header
        const sectionInfo = getColumnSection(originalHeader);
        const contentType = sectionInfo.contentType;
        
        // Handle section changes based on content type
        if (currentContentType !== contentType) {
          if (currentContentType !== null && currentContentType !== undefined && typeof currentContentType === 'string' && currentCount > 0) {
            const sectionName = currentContentType.charAt(0).toUpperCase() + currentContentType.slice(1);
            sections.push({ 
              name: sectionName, 
              columns: currentCount 
            });
          }
          currentContentType = contentType;
          currentCount = 1; // Count the main column
        } else {
          currentCount++; // Count additional columns in same content type
        }
        
        // Add change indicator column
        if (isChangeColumn) {
          currentCount++;
        }
      });
      
      // Add the last section
      if (currentContentType !== null && currentContentType !== undefined && typeof currentContentType === 'string' && currentCount > 0) {
        const sectionName = currentContentType.charAt(0).toUpperCase() + currentContentType.slice(1);
        sections.push({ 
          name: sectionName, 
          columns: currentCount 
        });
      }
      
      return sections;
    }

    // Helper functions for section colors
    function getSectionColor(sectionName) {
      const sectionLower = sectionName.toLowerCase();
      if (sectionLower.includes('placements')) return 'bg-blue-100';
      if (sectionLower.includes('enrichment')) return 'bg-teal-100'; // switched to teal for enrichment
      if (sectionLower.includes('employment')) return 'bg-purple-100';
      if (sectionLower.includes('careers')) return 'bg-yellow-100';
      if (sectionLower.includes('assessments')) return 'bg-green-200';
      if (sectionLower.includes('targets')) return 'bg-pink-100';
      if (sectionLower.includes('login')) return 'bg-indigo-100';
      if (sectionLower.includes('department')) return 'bg-amber-100';
      return 'bg-gray-100';
    }
    
    function getSectionInlineColor(sectionName) {
      const sectionLower = sectionName.toLowerCase();
      if (sectionLower.includes('placements')) return '#dbeafe';
      if (sectionLower.includes('enrichment')) return '#ccfbf1'; // switched to teal for enrichment
      if (sectionLower.includes('employment')) return '#f3e8ff';
      if (sectionLower.includes('careers')) return '#fef3c7';
      if (sectionLower.includes('assessments')) return '#bbf7d0';
      if (sectionLower.includes('targets')) return '#fce7f3';
      if (sectionLower.includes('login')) return '#e0e7ff';
      if (sectionLower.includes('department')) return '#fef3c7';
      return '#f3f4f6';
    }

    // Function to determine column section and color based on filename content
    // CACHE-BUST: 2025-09-16-08-31-00
    function getColumnSection(header) {
      console.log('=== getColumnSection called with header:', header);
      // Quick-revert flag
      if (typeof window.useStrictTypePrecedence === 'undefined') {
        window.useStrictTypePrecedence = true;
      }

      // Define content-based colors - unified canonical palette
      const CONTENT_COLORS = {
        'placements': 'bg-blue-100',         // Blue for placements
        'enrichment': 'bg-teal-100',         // Teal for enrichment
        'employment': 'bg-purple-100',       // Purple for employment
        'careers': 'bg-yellow-100',          // Yellow for careers
        'assessments': 'bg-green-200',       // Green-200 for assessments
        'activities-combined': 'bg-lime-100',// Lime for Activities Combined KC
        'targets': 'bg-pink-100',            // Pink for targets
        'login': 'bg-indigo-100',            // Indigo for login data
        'default': 'bg-gray-100'             // Gray for unknown
      };
      
      // Define inline styles as fallback for better specificity
      const INLINE_COLORS = {
        'placements': 'background-color: #dbeafe !important; border-color: #dbeafe !important;',
        'enrichment': 'background-color: #ccfbf1 !important; border-color: #ccfbf1 !important;',
        'employment': 'background-color: #f3e8ff !important; border-color: #f3e8ff !important;',
        'careers': 'background-color: #fef3c7 !important; border-color: #fef3c7 !important;',
        'assessments': 'background-color: #bbf7d0 !important; border-color: #bbf7d0 !important;',
        'activities-combined': 'background-color: #ecfccb !important; border-color: #ecfccb !important;',
        'targets': 'background-color: #fce7f3 !important; border-color: #fce7f3 !important;',
        'login': 'background-color: #e0e7ff !important; border-color: #e0e7ff !important;',
        'default': 'background-color: #f3f4f6 !important; border-color: #f3f4f6 !important;'
      };

      // Utility: normalise header for matching
      const rawHeader = header;
      // Remove (DEFAULT) but KEEP the [FileLabel] for label-preserving lookup
      const rawHeaderNoDefaultKeepLabel = String(rawHeader || '').replace(/\(default\)/ig, '').trim();
      // Strip injected UI markers like (DEFAULT) and trailing [FileLabel] entirely for base lookups
      const rawHeaderStripped = String(rawHeader || '')
        .replace(/\(default\)/ig, '')
        .replace(/\s*\[[^\]]+\]\s*$/,'')
        .trim();
      const headerLower = String(rawHeaderStripped || '').toLowerCase();
      const headerWithoutChange = headerLower.replace(/\s*\+\/\-\s*$/, '');
      // Treat both "(Employer Engagement)" and "(Employer Activity)" as employer for mapping purposes
      const headerNoEmpSuffix = headerWithoutChange
        .replace(/\s*\(employer engagement\)$/, ' (employer)')
        .replace(/\s*\(employer activity\)$/, ' (employer)');
      const headerNoEnrSuffix = headerNoEmpSuffix.replace(/\s*\(enrichment\)$/, ' (enrichment)');

      // 1) File-derived type via headerFileMap -> fileInfo
      function getFileDerivedType() {
        try {
          if (!window.headerFileMap || !window.fileInfo) return null;
          // Try multiple variants: original, stripped, normalised, and base without any trailing parenthetical
          const baseNoParen = rawHeaderStripped.replace(/\s*\(.*\)$/, '');
          const directIdx = window.headerFileMap[rawHeader]
            ?? window.headerFileMap[rawHeaderNoDefaultKeepLabel]
            ?? window.headerFileMap[rawHeaderStripped]
            ?? window.headerFileMap[headerNoEnrSuffix]
            ?? window.headerFileMap[headerNoEmpSuffix]
            ?? window.headerFileMap[baseNoParen];
          let idx = directIdx;
          // CRITICAL: Check for undefined/null explicitly, not falsy (0 is a valid file index!)
          if (typeof idx !== 'number') {
            // Fallback: use [FileLabel] suffix to resolve file index
            const m = String(rawHeader).match(/\[([^\]]+)\]\s*$/);
            if (m && m[1] && Array.isArray(window.fileInfo)) {
              const label = m[1].trim();
              for (let i = 0; i < window.fileInfo.length; i++) {
                if (window.fileInfo[i] && window.fileInfo[i].label === label) {
                  idx = i; break;
                }
              }
            }
            if (typeof idx !== 'number') return null;
          }
          const info = window.fileInfo[idx];
          const t = info && info.contentType ? String(info.contentType).toLowerCase() : null;
          if (!t) return null;
          if (t === 'employer') return 'employment';
          if (t === 'enrichment') return 'enrichment';
          // placements, careers, assessments, targets, login, etc. pass through
          return t;
        } catch (_) { return null; }
      }
      
      // Get custom colour from file info
      function getCustomColor() {
        try {
          if (!window.headerFileMap || !window.fileInfo) {
            console.log(`getCustomColor: No headerFileMap or fileInfo available for "${rawHeader}"`);
            return null;
          }
          const baseNoParen = rawHeaderStripped.replace(/\s*\(.*\)$/, '');
          // Infer desired type from header text (suffixes)
          const typeHint = (() => {
            const h = headerWithoutChange;
            if (/(employer\s+(engagement|activity)|\(employer\))/i.test(h)) return 'employment';
            if (/(enrichment(\s+activity)?|\(enrichment\))/i.test(h)) return 'enrichment';
            return '';
          })();
          const directIdx = window.headerFileMap[rawHeader]
            ?? window.headerFileMap[rawHeaderStripped]
            ?? window.headerFileMap[headerNoEnrSuffix]
            ?? window.headerFileMap[headerNoEmpSuffix]
            ?? window.headerFileMap[baseNoParen];
          console.log(`getCustomColor: Looking for "${rawHeader}" -> fileIdx: ${directIdx}`);
          let idx = directIdx;
          // CRITICAL: Check for number type explicitly, not falsy (0 is a valid file index!)
          if (typeof idx !== 'number') {
            // Fallback: try to derive by [FileLabel]
            const m = String(rawHeader).match(/\[([^\]]+)\]\s*$/);
            if (m && m[1] && Array.isArray(window.fileInfo)) {
              const label = m[1].trim();
              for (let i = 0; i < window.fileInfo.length; i++) {
                if (window.fileInfo[i] && window.fileInfo[i].label === label) {
                  idx = i; break;
                }
              }
            }
            // If still not found, try base-match across headerFileMap with type preference
            if (typeof idx !== 'number') {
              const stripBase = s => String(s || '')
                .replace(/\s*\[[^\]]+\]\s*$/, '')
                .replace(/\s*\+\/\-\s*$/, '')
                .replace(/\s*\([^)]*\)\s*$/, '')
                .trim()
                .toLowerCase();
              const target = stripBase(rawHeader);
              let candidate = undefined;
              // Pass 1: prefer a file whose contentType matches typeHint
              for (const [k, v] of Object.entries(window.headerFileMap)) {
                if (stripBase(k) === target) {
                  const fiType = (window.fileInfo[v] && window.fileInfo[v].contentType) ? String(window.fileInfo[v].contentType).toLowerCase() : '';
                  const normFiType = (fiType === 'employer') ? 'employment' : fiType;
                  if (typeHint && normFiType === typeHint) { candidate = v; break; }
                  if (candidate === undefined) candidate = v; // keep first as fallback
                }
              }
              if (candidate !== undefined) idx = candidate;
            }
            if (typeof idx !== 'number') {
              console.log(`getCustomColor: No file index found for "${rawHeader}"`);
              return null;
            }
          }
          const info = window.fileInfo[idx];
          console.log(`getCustomColor: File info for index ${idx}:`, info);
          // If the inferred type from header contradicts this file's type, do not apply its custom color
          if (info && info.contentType && typeHint) {
            const norm = String(info.contentType).toLowerCase() === 'employer' ? 'employment' : String(info.contentType).toLowerCase();
            if (norm && norm !== typeHint) {
              console.log('getCustomColor: file type mismatch with header hint; skipping custom color');
              return null;
            }
          }
          const customColor = info && info.customColor ? info.customColor : null;
          console.log(`getCustomColor: Custom color for "${rawHeader}": ${customColor}`);
          return customColor;
        } catch (e) { 
          console.log(`getCustomColor: Error for "${rawHeader}":`, e);
          return null; 
        }
      }

      // Resolve any manual per-file selection (type/color) saved from the dropdowns
      function getManualSelection() {
        try {
          if (!window.headerFileMap || !Array.isArray(window.fileInfo)) return null;
          const baseNoParen = rawHeaderStripped.replace(/\s*\(.*\)$/, '');
          const directIdx = window.headerFileMap[rawHeader]
            ?? window.headerFileMap[rawHeaderNoDefaultKeepLabel]
            ?? window.headerFileMap[rawHeaderStripped]
            ?? window.headerFileMap[headerNoEnrSuffix]
            ?? window.headerFileMap[headerNoEmpSuffix]
            ?? window.headerFileMap[baseNoParen];
          let idx = directIdx;
          // CRITICAL: Check for number type explicitly, not falsy (0 is a valid file index!)
          if (typeof idx !== 'number') {
            // Fallback: try to derive by [FileLabel]
            const m = String(rawHeader).match(/\[([^\]]+)\]\s*$/);
            if (m && m[1] && Array.isArray(window.fileInfo)) {
              const label = m[1].trim();
              for (let i = 0; i < window.fileInfo.length; i++) {
                if (window.fileInfo[i] && window.fileInfo[i].label === label) { idx = i; break; }
              }
            }
          }
          if (typeof idx !== 'number') return null;
          let sel = (window.__fileLevelSelections && window.__fileLevelSelections[idx]) ? window.__fileLevelSelections[idx] : null;
          // Fallback to reading live DOM controls if Apply hasn't been pressed yet
          if (!sel) {
            try {
              const typeEl = document.querySelector(`.file-assignment-type[data-file-index="${idx}"]`);
              const colorEl = document.querySelector(`.file-assignment-color[data-file-index="${idx}"]`);
              const typeVal = typeEl ? String(typeEl.value || '').toLowerCase() : '';
              const colorVal = colorEl ? String(colorEl.value || '') : '';
              if (typeVal || colorVal) sel = { type: typeVal, color: colorVal };
            } catch(_) {}
          }
          if (!sel) return null;
          const t = sel.type ? String(sel.type).toLowerCase() : '';
          const normType = (t === 'employer') ? 'employment' : t;
          return { type: normType || null, color: sel.color || null };
        } catch (_) { return null; }
      }

      // 2) Suffix-based explicit type
      function getSuffixType() {
        // Check for explicit suffixes first (these take precedence)
        // IMPORTANT: Check for placements BEFORE employer engagement to differentiate them
        if (headerWithoutChange.includes('(placements)')) return 'placements';
        if (headerWithoutChange.includes('placement') && headerWithoutChange.includes('(employer engagement)')) return 'placements';
        if (headerWithoutChange.includes('(employer engagement)')) return 'employment';
        if (headerWithoutChange.includes('(employer activity)')) return 'employment';
        if (headerWithoutChange.includes('(enrichment)')) return 'enrichment';
        if (headerWithoutChange.includes('(careers)')) return 'careers';
        if (headerWithoutChange.includes('(assessments)')) return 'assessments';
        if (headerWithoutChange.includes('(targets)')) return 'targets';
        if (headerWithoutChange.includes('(login)')) return 'login';
        
        // Then check for keyword patterns
        if (headerWithoutChange.includes('placement')) return 'placements';
        return null;
      }

      // 3) Data-driven activity header map (built during adaptTableToData)
      function getActivityMapType() {
        try {
          const map = window.activityHeaderTypeMap || {};
          const v = map[rawHeader] || map[rawHeader.replace(/\s*\(employer engagement\)$/i, '')] || map[rawHeader.replace(/\s*\(enrichment\)$/i, '')];
          return v || null; // returns 'employment' or 'enrichment'
        } catch (_) { return null; }
      }

      // 4) Keyword fallback
      function getKeywordType() {
        // IMPORTANT: Check for placements BEFORE employer engagement to differentiate them
        const hl = headerWithoutChange;
        // Placements: broaden to cover common column names used in reports
        if (
          hl.includes('placement') ||
          hl.includes('total placements') ||
          hl.includes('students with placements') ||
          hl.includes('% with placements') ||
          hl.includes('student confirmed') ||
          hl.includes('employer confirmed') ||
          hl.includes('hours scheduled') ||
          hl.includes('scheduled to date')
        ) return 'placements';

        // Activities (explicit)
        if (hl.includes('enrichment') || hl.includes('enrich')) return 'enrichment';
        if ((hl.includes('employer') && (hl.includes('engagement') || hl.includes('activity') || hl.includes('activities'))) || hl.includes('(employer)')) return 'employment';

        // Careers
        if (hl.includes('career') || hl.includes('job profile') || hl.includes('quiz') || hl.includes('mapped')) return 'careers';

        // Assessments
        if (hl.includes('assessment') || hl.includes('score') || hl.includes('average score')) return 'assessments';

        // Targets
        if (hl.includes('target')) return 'targets';

        // Login/Access
        if (hl.includes('login') || hl.includes('access')) return 'login';

        return 'default';
      }

      let contentType;
      const manualSel = getManualSelection();
      const suffixType = getSuffixType();
      const fileDerivedType = getFileDerivedType();
      const activityMapType = getActivityMapType();
      const keywordType = getKeywordType();
      
      console.log(`=== TYPE RESOLUTION for "${header}" ===`);
      console.log(`Suffix type: ${suffixType}`);
      console.log(`Manual selection: ${manualSel ? JSON.stringify(manualSel) : 'null'}`);
      console.log(`File-derived type: ${fileDerivedType}`);
      console.log(`Activity map type: ${activityMapType}`);
      console.log(`Keyword type: ${keywordType}`);
      
      if (window.useStrictTypePrecedence) {
        // Prefer explicit header suffixes, then user dropdown selection, then file-derived type
        contentType = suffixType || (manualSel && manualSel.type) || fileDerivedType || activityMapType || keywordType || 'default';
      } else {
        // Legacy behaviour fallback
        contentType = suffixType || (manualSel && manualSel.type) || activityMapType || keywordType || 'default';
      }
      
      console.log(`Final content type: ${contentType}`);

      // Check for custom colour - distinguish between user-selected and auto-inferred
      const userSelectedColor = manualSel && manualSel.color; // From dropdown/color picker
      const autoInferredColor = getCustomColor(); // From fileInfo contentType
      let customColor = userSelectedColor || autoInferredColor;
      
      // CRITICAL FIX: If header has explicit activity suffix, validate AUTO-INFERRED colors
      // User-selected colors are ALWAYS honored, but auto-inferred colors must match the suffix type
      if (!userSelectedColor && autoInferredColor && (contentType === 'enrichment' || contentType === 'employment')) {
        const expectedColor = (contentType === 'enrichment') ? '#ccfbf1' : '#f3e8ff';
        if (autoInferredColor !== expectedColor) {
          console.warn(`‚ö†Ô∏è Auto-inferred color "${autoInferredColor}" conflicts with activity type "${contentType}". Discarding and using default activity color.`);
          customColor = null; // Discard conflicting auto-inferred color
        }
      }
      
      let color, inlineColor;
      
      console.log(`=== COLOR DECISION for "${header}" ===`);
      console.log(`Custom color found: ${customColor}`);
      console.log(`Content type: ${contentType}`);
      console.log(`Header file map keys:`, Object.keys(window.headerFileMap || {}));
      console.log(`Header file map for "${header}":`, window.headerFileMap?.[header]);
      console.log(`Header variations:`, {
        rawHeader: rawHeader,
        headerNoEmpSuffix: headerNoEmpSuffix,
        headerNoEnrSuffix: headerNoEnrSuffix,
        withoutSuffix: rawHeader.replace(/\s*\(.*\)$/, '')
      });
      console.log(`File info length:`, window.fileInfo?.length);
      console.log(`File info:`, window.fileInfo);
      
      if (customColor) {
        // Use custom colour
        color = 'custom';
        inlineColor = `background-color: ${customColor} !important; border-color: ${customColor} !important;`;
        console.log(`‚úÖ Header "${header}" -> using custom color: "${customColor}"`);
      } else {
        // Use default colours
        color = CONTENT_COLORS[contentType] || CONTENT_COLORS.default;
        inlineColor = INLINE_COLORS[contentType] || INLINE_COLORS.default;
        console.log(`‚ùå Header "${header}" -> NO custom color, using contentType: "${contentType}" -> color: "${color}"`);
      }
      
      // Capitalize first letter for display
      const sectionName = contentType.charAt(0).toUpperCase() + contentType.slice(1);
      
      const result = { 
        section: sectionName,
        color: color,
        contentType: contentType,
        inlineColor: inlineColor
      };
      
      console.log(`getColumnSection result for "${header}":`, result);
      return result;
    }

    function renderTable() {
      console.log('=== renderTable called ===');
      console.log('tableHeaders:', tableHeaders);
      console.log('tableHeaders length:', tableHeaders ? tableHeaders.length : 'undefined');
      console.log('tableData length:', tableData ? tableData.length : 'undefined');
      console.log('window.useOriginalHeaders:', window.useOriginalHeaders);
      const header = document.getElementById('tableHeader');
      const body = document.getElementById('tableBody');
      
      if (!header || !body) {
        console.error('Header or body element not found!');
        return;
      }
      
      // Helper: normalise header to match headerFileMap keys
      function normaliseHeaderForMap(h) {
        if (!h) return h;
        const base = h.replace(/ \+\/-?$/, '');
        if (/(\(Employer Engagement\))$/i.test(base)) {
          return base.replace(/ \(Employer Engagement\)$/i, ' (employer)');
        }
        if (/(\(Enrichment\))$/i.test(base)) {
          return base.replace(/ \(Enrichment\)$/i, ' (enrichment)');
        }
        return base;
      }
      
      // Helper: get file index for header
      function getHeaderFileIndex(h) {
        const direct = headerFileMap[h];
        if (direct !== undefined) return direct;
        const norm = normaliseHeaderForMap(h);
        if (norm !== h && headerFileMap[norm] !== undefined) return headerFileMap[norm];
        // Fallback: try matching by base name ignoring any suffix
        const base = h.replace(/ \(.*\)$/, '');
        for (const key in headerFileMap) {
          if (key.startsWith(base + ' (')) return headerFileMap[key];
        }
        // Fallback 2: match by stripped [FileLabel] suffix
        try {
          const strippedH = stripFileLabel(h);
          for (const key in headerFileMap) {
            if (stripFileLabel(key) === strippedH) {
              return headerFileMap[key];
            }
          }
        } catch(_) {}
        // Fallback 3: resolve by [FileLabel] suffix in the provided header
        const m = String(h).match(/\[([^\]]+)\]\s*$/);
        if (m && m[1] && Array.isArray(window.fileInfo)) {
          const label = m[1].trim();
          for (let i = 0; i < window.fileInfo.length; i++) {
            if (window.fileInfo[i] && window.fileInfo[i].label === label) {
              return i;
            }
          }
        }
        return undefined;
      }
      
      // File accent colours to differentiate columns from different files
      const FILE_ACCENTS = ['#1d4ed8', '#9333ea', '#059669', '#ea580c', '#dc2626', '#0ea5e9', '#f59e0b'];
      function getFileAccentColor(idx) {
        if (idx === undefined) return null;
        // Use custom colour from fileInfo if available, otherwise use default accent
        if (window.fileInfo && window.fileInfo[idx] && window.fileInfo[idx].customColor) {
          return window.fileInfo[idx].customColor;
        }
        return FILE_ACCENTS[idx % FILE_ACCENTS.length];
      }
      
      // Build complete header structure with change columns
      let completeHeaders = [];
      let changeColumnIndices = [];
      
      console.log('Building completeHeaders from tableHeaders:', tableHeaders);
      tableHeaders.forEach((h, colIdx) => {
        console.log(`Processing header ${colIdx}: "${h}"`);
        completeHeaders.push(h);
        // Show change +/- columns by default, even in strict template mode, unless explicitly disabled
        if (window.forceShowChangeColumns !== false) {
          if (h !== 'Department' && (h.toLowerCase().includes('percent') || h.includes('%') || 
              h.toLowerCase().includes('total') || h.toLowerCase().includes('students') || 
              h.toLowerCase().includes('hours') || h.toLowerCase().includes('score') || 
              h.toLowerCase().includes('activities'))) {
            completeHeaders.push(`${h} +/-`);
            changeColumnIndices.push(completeHeaders.length - 1);
          }
        }
      });
      
      console.log('completeHeaders built:', completeHeaders);
      console.log('completeHeaders length:', completeHeaders.length);
      
      // Create section headers only if explicitly enabled
      let headerHTML = '';
      if (!window.useOriginalHeaders && window.showSectionRows === true) {
        const sectionHeaders = createSectionHeaders(completeHeaders);
        // Render section headers first
        sectionHeaders.forEach(section => {
          if (section.columns > 0) {
            // Get the appropriate color for this section
            const sectionColor = getSectionColor(section.name);
            headerHTML += `<tr><th colspan="${section.columns}" class="px-6 py-2 text-left text-sm font-semibold text-gray-900 border-b-2 border-gray-300 ${sectionColor}" style="background-color: ${getSectionInlineColor(section.name)} !important;">${section.name}</th></tr>`;
          }
        });
      }
      
      // Render data headers with or without section colors
      const headerCells = completeHeaders.map((h, colIdx) => {
        if (window.useOriginalHeaders) {
          // For original headers, use colors from Excel file if available
          let headerStyle = 'px-6 py-3 text-left text-xs font-medium text-gray-800 uppercase tracking-wider';
          let inlineStyle = '';
          
          if (tableHeaderColors && tableHeaderColors[colIdx]) {
            const color = tableHeaderColors[colIdx];
            inlineStyle = `background-color: ${color} !important; border-color: ${color} !important;`;
            console.log(`Rendering original header "${h}" with Excel color: ${color}`);
          } else {
            headerStyle += ' bg-gray-50';
            console.log(`Rendering original header "${h}" with default styling (no color found)`);
          }
          // Ensure activity headers display section suffix even in original-headers mode
          const isChange = h.endsWith(' +/-');
          const baseH = isChange ? h.replace(' +/-', '') : h;
          const baseDisp = stripFileLabel(baseH);
          const hasSuffix = /\(Employer Engagement\)|\(Enrichment\)|\(Employer Activity\)|\(Enrichment Activity\)|\(Activities Combined KC\)|\(activities-combined\)/i.test(baseDisp);
          let displayText;
          let tForEnforce = '';
          if (!hasSuffix) {
            // Determine type via fileIndex -> fileInfo and activityHeaderTypeMap
            let t = '';
            try {
              const idx = (typeof getHeaderFileIndex === 'function') ? getHeaderFileIndex(baseH) : undefined;
              const fiType = (Array.isArray(window.fileInfo) && window.fileInfo[idx] && window.fileInfo[idx].contentType) ? String(window.fileInfo[idx].contentType).toLowerCase() : '';
              if (fiType) t = fiType;
            } catch(_) {}
            if (!t || t === 'activities' || t === 'default') {
              try {
                const b = baseDisp.replace(/\s*\[[^\]]+\]\s*$/, '').replace(/\s*\([^)]*\)\s*$/, '');
                const map = window.activityHeaderTypeMap || {};
                let foundType = '';
                Object.keys(map).some(k => {
                  const stripped = String(k)
                    .replace(/\s*\[[^\]]+\]\s*$/, '')
                    .replace(/\s*\([^)]*\)\s*$/, '');
                  if (stripped === b) { foundType = map[k]; return true; }
                  return false;
                });
                if (foundType) t = foundType;
              } catch(_) {}
            }
            if (t === 'employment' || t === 'employer') {
              displayText = `${baseDisp} (Employer Engagement)`;
              tForEnforce = 'employment';
            } else if (t === 'enrichment') {
              displayText = `${baseDisp} (Enrichment)`;
              tForEnforce = 'enrichment';
            } else {
              displayText = baseDisp;
            }
          } else {
            displayText = baseDisp;
            try {
              if (/\(enrichment( activity)?\)/i.test(baseDisp)) tForEnforce = 'enrichment';
              else if (/\(employer (engagement|activity)\)/i.test(baseDisp)) tForEnforce = 'employment';
              else if (/\((activities combined kc|activities-combined)\)/i.test(baseDisp)) tForEnforce = 'activities-combined';
            } catch(_) {}
          }
          if (isChange) displayText += ' +/-';
          // Enforce canonical section color for activity headers in original-headers mode
          try {
            const ENFORCE_INLINE = {
              'enrichment': 'background-color: #ccfbf1 !important; border-color: #ccfbf1 !important;',
              'employment': 'background-color: #f3e8ff !important; border-color: #f3e8ff !important;',
              'activities-combined': 'background-color: #ecfccb !important; border-color: #ecfccb !important;'
            };
            if (tForEnforce && ENFORCE_INLINE[tForEnforce]) {
              inlineStyle = ENFORCE_INLINE[tForEnforce];
            }
          } catch(_) {}
          
          return `<th class="${headerStyle}" style="${inlineStyle}">${displayText}</th>`;
        } else {
          // Determine if this is a change column and get section color
          const isChangeColumn = h.endsWith(' +/-');
          const originalHeader = isChangeColumn ? h.replace(' +/-', '') : h;
          const sectionInfo = getColumnSection(originalHeader);
          // Enforce activity suffix colouring as a final override to avoid any mis-inference
          const SUFFIX_INLINE = {
            enrichment: 'background-color: #ccfbf1 !important; border-color: #ccfbf1 !important;',
            employment: 'background-color: #f3e8ff !important; border-color: #f3e8ff !important;'
          };
          const SUFFIX_CLASS = {
            enrichment: 'bg-teal-100',
            employment: 'bg-purple-100'
          };
          let enforcedType = '';
          try {
            const oh = String(originalHeader || '');
            const ohLower = oh.toLowerCase();
            const baseDispForEnf = stripFileLabel(oh);
            const baseLower = baseDispForEnf.toLowerCase();
            // Detect placements bases first and lock colouring to placements
            const isPlacementBase = (
              baseLower.includes('placement') ||
              baseLower.includes('total placements') ||
              baseLower.includes('students with placements') ||
              baseLower.includes('% with placements') ||
              baseLower.includes('hours scheduled to date') ||
              baseLower.includes('hours scheduled') ||
              baseLower.includes('scheduled to date') ||
              baseLower.includes('student confirmed') ||
              baseLower.includes('employer confirmed')
            );
            if (/\(enrichment( activity)?\)/i.test(oh) || /\(enrichment( activity)?\)/i.test(baseDispForEnf)) enforcedType = 'enrichment';
            else if (/\(employer (engagement|activity)\)/i.test(oh) || /\(employer (engagement|activity)\)/i.test(baseDispForEnf)) enforcedType = 'employment';
            else if (ohLower.includes('(enrichment)') || baseLower.includes('(enrichment)')) enforcedType = 'enrichment';
            else if (ohLower.includes('(employer engagement)') || ohLower.includes('(employer activity)') || baseLower.includes('(employer engagement)') || baseLower.includes('(employer activity)')) enforcedType = 'employment';
            // If this is a placements header, override any enforcedType to placements
            if (isPlacementBase) enforcedType = 'placements';
          } catch(_) {}
          const originalIdx = tableHeaders.indexOf(originalHeader);
          
          // File-based accent (disabled for previous style) ‚Äî keep variables for potential future use
          const fileIdx = getHeaderFileIndex(originalHeader);
          const accent = getFileAccentColor(fileIdx);
          const accentStyle = '';
          const dot = '';
          
          // Use light section background; file accent is shown via left border and dot only (previous style)
          // Check if user manually selected a color via dropdown for this header's file
          const manualFileIdx = getHeaderFileIndex(originalHeader);
          const hasUserSelectedColor = (window.__fileLevelSelections && 
                                        typeof manualFileIdx === 'number' &&
                                        window.__fileLevelSelections[manualFileIdx] && 
                                        window.__fileLevelSelections[manualFileIdx].color);
          
          let inline = sectionInfo.inlineColor;
          let colorClass = sectionInfo.color;
          const isCustom = (sectionInfo && sectionInfo.color === 'custom') || hasUserSelectedColor;
          
          console.log(`Before enforcement - colorClass: "${colorClass}", inline includes: ${inline?.substring(0, 50)}, isCustom: ${isCustom}, hasUserSelectedColor: ${hasUserSelectedColor}, enforcedType: ${enforcedType}`);
          
          if (enforcedType) {
            if (enforcedType === 'placements') {
              // Align type to placements but preserve any custom color chosen by the user
              if (!isCustom) {
                inline = getSectionInlineColor('placements');
                colorClass = SECTION_COLORS['placements'] || colorClass;
              }
              try { sectionInfo.contentType = 'placements'; } catch(_) {}
            } else if (enforcedType === 'enrichment' || enforcedType === 'employment') {
              // ALWAYS enforce enrichment/employer engagement colors based on suffix tags
              // These are semantic categories that must have consistent colors
              inline = SUFFIX_INLINE[enforcedType];
              colorClass = SUFFIX_CLASS[enforcedType];
              console.log(`Enforcing ${enforcedType} color: ${colorClass}`);
              // Always reflect correct contentType for text-suffix logic
              try { sectionInfo.contentType = enforcedType; } catch(_) {}
            }
          } else if (sectionInfo.contentType === 'enrichment' || sectionInfo.contentType === 'employment') {
            // Even if no enforcedType, ensure activity types have correct colors
            const actType = sectionInfo.contentType;
            if (SUFFIX_INLINE[actType]) inline = SUFFIX_INLINE[actType];
            if (SUFFIX_CLASS[actType]) colorClass = SUFFIX_CLASS[actType];
          }
          
          console.log(`After enforcement - colorClass: "${colorClass}", inline includes: ${inline?.substring(0, 50)}`);
          
          console.log(`Rendering header "${h}" (original: "${originalHeader}") -> type: ${sectionInfo.contentType}, enforcedType: ${enforcedType || 'none'}, class: "${colorClass}", inline: "${inline}", fileIdx: ${fileIdx}`);
          
          const isSelected = editMode && (selectedColumns.has(originalIdx) || lastSelectedColIndex === originalIdx);
          const selectedClass = (isSelected ? ' ring-2 ring-blue-400 bg-yellow-100' : '');
          const checkbox = editMode && !isChangeColumn
            ? `<input type="checkbox" class="col-select mr-2 align-middle" data-colidx="${originalIdx}" ${selectedColumns.has(originalIdx) ? 'checked' : ''}>`
            : '';
          const draggable = editMode && !isChangeColumn ? 'draggable="true"' : '';
          // Build display text: keep header key intact, but ensure activity columns show the section name
          let displayText;
          const baseDisp = stripFileLabel(originalHeader);
          if (isChangeColumn) {
            // Determine type for +/- companion as well
            let t = (sectionInfo && sectionInfo.contentType) ? String(sectionInfo.contentType).toLowerCase() : '';
            if (!t || t === 'activities' || t === 'default') {
              try {
                const idx = getHeaderFileIndex(originalHeader);
                const fiType = (Array.isArray(window.fileInfo) && window.fileInfo[idx] && window.fileInfo[idx].contentType) ? String(window.fileInfo[idx].contentType).toLowerCase() : '';
                if (fiType) t = fiType;
              } catch(_) {}
            }
            if (!t || t === 'activities' || t === 'default') {
              try {
                const b = baseDisp.replace(/\s*\[[^\]]+\]\s*$/, '');
                const map = window.activityHeaderTypeMap || {};
                let foundType = '';
                Object.keys(map).some(k => {
                  const stripped = String(k).replace(/\s*\[[^\]]+\]\s*$/, '');
                  if (stripped === b) { foundType = map[k]; return true; }
                  return false;
                });
                if (foundType) t = foundType;
              } catch(_) {}
            }
            // After resolving t, sync colour to t if it's an activity
            try {
              const tn = (t === 'employer') ? 'employment' : t;
              if (tn === 'enrichment' || tn === 'employment') {
                inline = SUFFIX_INLINE[tn] || inline;
                colorClass = SUFFIX_CLASS[tn] || colorClass;
                sectionInfo.contentType = tn;
              }
            } catch(_) {}
            if (/\(Employer Engagement\)|\(Enrichment\)|\(Employer Activity\)|\(Enrichment Activity\)/i.test(baseDisp)) {
              displayText = baseDisp + ' +/-';
            } else if (t === 'employment' || t === 'employer') {
              displayText = `${baseDisp} (Employer Engagement) +/-`;
            } else if (t === 'enrichment') {
              displayText = `${baseDisp} (Enrichment) +/-`;
            } else {
              displayText = baseDisp + ' +/-';
            }
          } else {
            const hasSuffix = /\(Employer Engagement\)|\(Enrichment\)|\(Employer Activity\)|\(Enrichment Activity\)/i.test(baseDisp);
            if (!hasSuffix) {
              // Determine type robustly: sectionInfo -> file index -> activity map
              let t = (sectionInfo && sectionInfo.contentType) ? String(sectionInfo.contentType).toLowerCase() : '';
              if (!t || t === 'activities' || t === 'default') {
                // Try file-based detection
                try {
                  const idx = getHeaderFileIndex(originalHeader);
                  const fiType = (Array.isArray(window.fileInfo) && window.fileInfo[idx] && window.fileInfo[idx].contentType) ? String(window.fileInfo[idx].contentType).toLowerCase() : '';
                  if (fiType) t = fiType;
                } catch(_) {}
              }
              if (!t || t === 'activities' || t === 'default') {
                // Try activity header type map (using base without [Label] or (suffix))
                try {
                  const b = baseDisp.replace(/\s*\[[^\]]+\]\s*$/, '').replace(/\s*\([^)]*\)\s*$/, '');
                  const map = window.activityHeaderTypeMap || {};
                  let foundType = '';
                  Object.keys(map).some(k => {
                    const stripped = String(k)
                      .replace(/\s*\[[^\]]+\]\s*$/, '')
                      .replace(/\s*\([^)]*\)\s*$/, '');
                    if (stripped === b) { foundType = map[k]; return true; }
                    return false;
                  });
                  if (foundType) t = foundType;
                } catch(_) {}
              }
              // After resolving t, sync colour to t if it's an activity
              try {
                const tn = (t === 'employer') ? 'employment' : t;
                if (tn === 'enrichment' || tn === 'employment') {
                  inline = SUFFIX_INLINE[tn] || inline;
                  colorClass = SUFFIX_CLASS[tn] || colorClass;
                  sectionInfo.contentType = tn;
                }
              } catch(_) {}
              if (t === 'employment' || t === 'employer') {
                displayText = `${baseDisp} (Employer Engagement)`;
              } else if (t === 'enrichment') {
                displayText = `${baseDisp} (Enrichment)`;
              } else {
                displayText = baseDisp;
              }
            } else {
              displayText = baseDisp;
            }
          }
          const styleAttr = `${inline}${accentStyle ? ' ' + accentStyle : ''} cursor:pointer;`;
          return `<th ${draggable} class="px-6 py-3 text-left text-xs font-medium text-gray-800 uppercase tracking-wider ${colorClass}${selectedClass}" data-col-idx="${colIdx}" data-original-idx="${originalIdx}" data-header-key="${encodeURIComponent(originalHeader)}" style="${styleAttr}">${checkbox}${dot}${displayText}</th>`;
        }
      }).join('');
      
      const allRowsSelected = editMode ? (selectedRows.size === tableData.length && tableData.length > 0) : false;
      const selectHeaderCell = editMode ? `<th class="px-2 py-3 text-left text-xs font-medium text-gray-700"><input type="checkbox" id="selectAllRows" class="mr-2" ${allRowsSelected ? 'checked' : ''}> Sel</th>` : '';
      headerHTML += `<tr>${selectHeaderCell}${headerCells}</tr>`;
      // Final safety: strip any trailing [Label] right before closing th, in case any slipped through
      try { headerHTML = headerHTML.replace(/\s*\[[^\]]+\](?=\s*<\/th>)/gi, ''); } catch(_) {}
      header.innerHTML = headerHTML;
      // No sticky header re-application to preserve original header colouring
      
      // Render body with proper column alignment
      body.innerHTML = tableData.map((row, rowIdx) => {
        let completeRowCells = [];
        
        if (editMode) {
          const rowChecked = selectedRows.has(rowIdx) ? 'checked' : '';
          completeRowCells.push(`<td class="px-2 py-4 whitespace-nowrap text-sm text-gray-900"><input type="checkbox" class="row-select" data-row="${rowIdx}" ${rowChecked}></td>`);
        }
        tableHeaders.forEach((header, originalColIdx) => {
          const cell = row[originalColIdx];
          let displayValue = cell;
          let percentageBar = '';

          // Ensure Department column is always treated as plain text
          if (isDepartmentHeader(header)) {
            displayValue = String(cell ?? '');
          }
          // In strict template mode, do not add visual decorations/formatting
          else if (window.forceShowChangeColumns !== false && header && (header.toLowerCase().includes('percent') || header.includes('%'))) {
            if (typeof cell === 'number' || !isNaN(parseFloat(cell))) {
              // Check if the value is already a percentage (0-100) or needs conversion (0-1)
              let percentage;
              if (parseFloat(cell) <= 1) {
                percentage = parseFloat(cell) * 100;
              } else {
                percentage = parseFloat(cell);
              }
              displayValue = percentage.toFixed(1) + '%';
              
              // Add percentage bar with gradient colors
              const barWidth = Math.min(percentage, 100);
              let barColor;
              if (percentage < 40) {
                barColor = 'bg-red-500';
              } else if (percentage >= 40 && percentage <= 70) {
                // Orange gradient between 40-70%
                const orangeIntensity = Math.round(255 - ((percentage - 40) / 30) * 100);
                barColor = `rgb(255, ${orangeIntensity}, 0)`;
              } else {
                // Green gradient above 70%
                const greenIntensity = Math.round(100 + ((percentage - 70) / 30) * 155);
                barColor = `rgb(0, ${greenIntensity}, 0)`;
              }
              
              percentageBar = `
                <div class="mt-1 w-full bg-gray-200 rounded-full h-2">
                  <div class="h-2 rounded-full transition-all duration-300 ${typeof barColor === 'string' && !barColor.startsWith('rgb') ? barColor : ''}" style="width: ${barWidth}%; ${typeof barColor === 'string' && barColor.startsWith('rgb') ? `background-color: ${barColor}` : ''}"></div>
                </div>
              `;
            } else {
              // No info => display 0% and a 0-width bar
              displayValue = '0.0%';
              percentageBar = `
                <div class="mt-1 w-full bg-gray-200 rounded-full h-2">
                  <div class="h-2 rounded-full transition-all duration-300" style="width: 0%"></div>
                </div>
              `;
            }
          }
          // Format numbers (but never for the Department column)
          else if (window.forceShowChangeColumns !== false && !isDepartmentHeader(header) && (typeof cell === 'number' || (!isNaN(parseFloat(cell)) && cell !== ''))) {
            displayValue = parseFloat(cell).toLocaleString();
          }
          
          // Add the main data cell with selection highlights and row index marker
          const headerKey = header;
          const isRowSelected = editMode && (selectedRows.has(rowIdx) || lastSelectedRowIndex === rowIdx);
          const isColSelected = editMode && (selectedColumns.has(headerKey) || lastSelectedColIndex === originalColIdx);
          const tdHighlight = isRowSelected || isColSelected ? ' bg-yellow-50' : '';
          completeRowCells.push(`
            <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900${tdHighlight}" data-row-idx="${rowIdx}">
              <div class="editable-cell" contenteditable="true" data-row="${rowIdx}" data-col="${originalColIdx}">${displayValue}</div>
              ${percentageBar}
            </td>
          `);
          
          // Add change indicator cell if this column should have one
          // Only add for percentage columns and numeric metric columns
          if (window.forceShowChangeColumns !== false && !isDepartmentHeader(header) && (header.toLowerCase().includes('percent') || header.includes('%') || 
              header.toLowerCase().includes('total') || header.toLowerCase().includes('students') || 
              header.toLowerCase().includes('hours') || header.toLowerCase().includes('score') || 
              header.toLowerCase().includes('activities'))) {
            let changeIndicator = '';
            
            // Calculate change from previous report
            if (previousReportData) {
              const previousRow = previousReportData.rows ? previousReportData.rows.find(r => r[0] === row[0]) : null;
              if (previousRow && previousRow[originalColIdx] !== undefined) {
                const isPercentHeader = header.toLowerCase().includes('percent') || header.includes('%');
                const rawCurrent = cell;
                const rawPrevious = previousRow[originalColIdx];
                const toPercent = (v) => {
                  const s = String(v ?? '').trim();
                  if (!s) return 0;
                  const num = parseFloat(s.replace(/%/g, ''));
                  if (isNaN(num)) return 0;
                  // If original string had % or looks like 0-100, keep as-is; if <=1, treat as ratio -> percent
                  if (/%\s*$/.test(s)) return num;
                  return Math.abs(num) <= 1 ? num * 100 : num;
                };
                let change;
                let changeText;
                if (isPercentHeader) {
                  const currentPct = toPercent(rawCurrent);
                  const previousPct = toPercent(rawPrevious);
                  change = currentPct - previousPct; // percentage points
                  changeText = (change > 0 ? `+${change.toFixed(1)}%` : `${change.toFixed(1)}%`);
                } else {
                  const currentValue = parseFloat(rawCurrent) || 0;
                  const previousValue = parseFloat(rawPrevious) || 0;
                  change = currentValue - previousValue;
                  changeText = change > 0 ? `+${change.toFixed(1)}` : change.toFixed(1);
                }
                const changeColor = change > 0 ? 'text-green-600' : (change < 0 ? 'text-red-600' : 'text-orange-600');
                const changeBg = change > 0 ? 'bg-green-100' : (change < 0 ? 'bg-red-100' : 'bg-orange-100');
                changeIndicator = `<span class="px-2 py-1 rounded text-xs font-medium ${changeBg} ${changeColor}">${changeText}</span>`;
              } else {
                // No previous same-template data found, treat as baseline (0)
                changeIndicator = `<span class="px-2 py-1 rounded text-xs font-medium bg-orange-100 text-orange-600">0</span>`;
              }
            } else {
              // No previous same-template report data available, treat as baseline (0)
              changeIndicator = `<span class="px-2 py-1 rounded text-xs font-medium bg-orange-100 text-orange-600">0</span>`;
            }
            
            completeRowCells.push(`
              <td class="px-2 py-4 whitespace-nowrap text-sm">
                ${changeIndicator}
              </td>
            `);
          }
        });
        
        return `<tr>${completeRowCells.join('')}</tr>`;
      }).join('');
      
      // Per-cell listeners disabled: we use delegated listeners in setupCellEditing() for performance
      // (Leaving this block intentionally inactive to avoid thousands of listeners on every render)
      
      // Update top/bottom scroll width after render
      try { updateScrollSync(); } catch(_) {}

      // Column/row quick select by click (kept)
      header.querySelectorAll('th[data-original-idx]').forEach(th => {
        th.addEventListener('click', () => {
          if (!editMode) return;
          const oidx = parseInt(th.dataset.originalIdx);
          if (!isNaN(oidx)) lastSelectedColIndex = oidx;
          if (!isNaN(oidx)) {
            if (selectedColumns.has(oidx)) selectedColumns.delete(oidx); else selectedColumns.add(oidx);
          }
          scheduleRender();
        });
      });
      body.querySelectorAll('td[data-row-idx]').forEach(td => {
        td.addEventListener('click', () => {
          if (!editMode) return;
          lastSelectedRowIndex = parseInt(td.dataset.rowIdx);
          scheduleRender();
        });
      });

      // Checkbox selection wiring
      if (editMode) {
        // Select All rows toggle
        const selectAll = document.getElementById('selectAllRows');
        if (selectAll) {
          selectAll.addEventListener('click', (e) => { e.stopPropagation(); });
          selectAll.addEventListener('change', (e) => {
            selectedRows.clear();
            if (e.target.checked) {
              for (let i = 0; i < tableData.length; i++) selectedRows.add(i);
            }
            scheduleRender();
          });
        }

        header.querySelectorAll('input.col-select').forEach(inp => {
          inp.addEventListener('click', (e) => { e.stopPropagation(); });
          inp.addEventListener('change', (e) => {
            const idx = parseInt(e.target.dataset.colidx);
            if (isNaN(idx)) return;
            if (e.target.checked) selectedColumns.add(idx); else selectedColumns.delete(idx);
            scheduleRender();
          });
        });
        body.querySelectorAll('input.row-select').forEach(inp => {
          inp.addEventListener('click', (e) => { e.stopPropagation(); });
          inp.addEventListener('change', (e) => {
            const idx = parseInt(e.target.dataset.row);
            if (e.target.checked) selectedRows.add(idx); else selectedRows.delete(idx);
            scheduleRender();
          });
        });
        // Drag & drop columns (use original index mapping)
        header.querySelectorAll('th[data-original-idx]').forEach(th => {
          if (!th.draggable) return;
          th.addEventListener('dragstart', (e) => {
            e.dataTransfer.setData('text/orig', th.dataset.originalIdx);
          });
          th.addEventListener('dragover', (e) => { e.preventDefault(); });
          th.addEventListener('drop', (e) => {
            e.preventDefault();
            const from = parseInt(e.dataTransfer.getData('text/orig'));
            const to = parseInt(th.dataset.originalIdx);
            if (isNaN(from) || isNaN(to) || from === to) return;
            const [movedHeader] = tableHeaders.splice(from, 1);
            tableHeaders.splice(to, 0, movedHeader);
            tableData.forEach(r => { const [cell] = r.splice(from, 1); r.splice(to, 0, cell); });
            lastSelectedColIndex = to;
            renderTable();
          });
        });
        // Drag & drop rows
        body.querySelectorAll('tr').forEach((tr, idx) => {
          tr.setAttribute('draggable', 'true');
          tr.addEventListener('dragstart', (e) => { e.dataTransfer.setData('text/row', String(idx)); });
          tr.addEventListener('dragover', (e) => { e.preventDefault(); });
          tr.addEventListener('drop', (e) => {
            e.preventDefault();
            const from = parseInt(e.dataTransfer.getData('text/row'));
            const to = idx;
            if (isNaN(from) || isNaN(to) || from === to) return;
            const [row] = tableData.splice(from, 1);
            tableData.splice(to, 0, row);
            lastSelectedRowIndex = to;
            renderTable();
          });
        });
      }
    }

    // Table editing functions
    function addRow() {
      if (!tableHeaders || tableHeaders.length === 0) {
        showStatus('No table data available. Please upload files first.', 'error');
        return;
      }
      
      const newRow = Array(tableHeaders.length).fill('');
      tableData.push(newRow);
      renderTable();
      showStatus('Row added successfully', 'success');
    }

    function addColumn() {
      const colName = prompt('Enter new column name:');
      if (!colName) return;
      
      if (!tableHeaders) {
        tableHeaders = [];
      }
      
      tableHeaders.push(colName);
      tableData.forEach(row => row.push(''));
      renderTable();
      showStatus(`Column "${colName}" added successfully`, 'success');
    }

    function smartDelete() {
      if (!tableData || tableData.length === 0) {
        showStatus('No data to delete', 'error');
        return;
      }
      
      if (!isSelectionMode) {
        toggleSelectionMode();
        return;
      }
      
      if (selectedRows.size === 0 && selectedColumns.size === 0) {
        showStatus('Please select rows or columns to delete', 'error');
        return;
      }
      
      // Delete selected rows
      if (selectedRows.size > 0) {
        const sortedRows = Array.from(selectedRows).sort((a, b) => b - a);
        sortedRows.forEach(rowIndex => {
          tableData.splice(rowIndex, 1);
        });
      }
      
      // Delete selected columns
      if (selectedColumns.size > 0) {
        const sortedColumns = Array.from(selectedColumns).sort((a, b) => b - a);
        sortedColumns.forEach(colIndex => {
          tableHeaders.splice(colIndex, 1);
          tableData.forEach(row => row.splice(colIndex, 1));
        });
      }
      
      selectedRows.clear();
      selectedColumns.clear();
      isSelectionMode = false;
      renderTable();
      showStatus('Selected items deleted successfully', 'success');
    }

    function toggleSelectionMode() {
      isSelectionMode = !isSelectionMode;
      selectedRows.clear();
      selectedColumns.clear();
      
      const cancelBtn = document.getElementById('cancelSelectionBtn');
      if (cancelBtn) {
        cancelBtn.classList.toggle('hidden', !isSelectionMode);
      }
      
      renderTable();
    }

    function toggleRowSelection(rowIndex) {
      if (!isSelectionMode) return;
      
      if (selectedRows.has(rowIndex)) {
        selectedRows.delete(rowIndex);
      } else {
        selectedRows.add(rowIndex);
      }
      renderTable();
    }

    function toggleColumnSelection(colIndex) {
      if (!isSelectionMode) return;
      
      if (selectedColumns.has(colIndex)) {
        selectedColumns.delete(colIndex);
      } else {
        selectedColumns.add(colIndex);
      }
      renderTable();
    }

    function toggleCellSelection(rowIndex, colIndex) {
      if (!isSelectionMode) return;
      
      toggleRowSelection(rowIndex);
      toggleColumnSelection(colIndex);
    }

    function updateCell(rowIndex, colIndex, value) {
      if (rowIndex < tableData.length && colIndex < tableData[rowIndex].length) {
        tableData[rowIndex][colIndex] = value;
      }
    }

    // Report generation
    async function generateReport() {
      const previewOnly = !currentCollegeId;
      if (!Array.isArray(tableHeaders) || !Array.isArray(tableData) || tableHeaders.length === 0) {
        showStatus('No data to generate report from', 'error');
        return;
      }
      
      try {
        // If no college selected, run a preview-only flow (no API call)
        if (previewOnly) {
          // Build display headers without trailing [FileLabel] suffixes and compute color meta
          const displayHeaders = (tableHeaders || []).map(h => stripFileLabel(h));
          const headerSections = {};
          const headerColorClasses = {};
          const headerHexColors = {};
          (tableHeaders || []).forEach((h, idx) => {
            const disp = displayHeaders[idx];
            const sec = (window.headerAssignments && window.headerAssignments[h]) || getSectionType(h);
            const cls = SECTION_COLORS[sec] || SECTION_COLORS.default;
            headerSections[disp] = sec;
            headerColorClasses[disp] = cls;
          });
          try { localStorage.setItem('previewMeta', JSON.stringify({ headerSections, headerColorClasses, headerHexColors })); } catch(_) {}
          showStatus('Preview ready. Select a college to generate and download the final report.', 'success');
          return;
        }

        // Build sensible defaults for final report export
        const college = (Array.isArray(colleges) ? colleges.find(c => String(c.id) === String(currentCollegeId)) : null);
        const defaultName = `Report - ${college?.name || 'College'} - ${new Date().toLocaleDateString()}`;
        const defaultSummary = '';
        const meta = await showReportMetaDialog(defaultName, defaultSummary);
        if (!meta) return; // user cancelled
        
        // Determine template identity
        const selectedTemplate = getSelectedTemplate();
        const tKey = selectedTemplate ? String(selectedTemplate.id) : computeHeaderSignature(tableHeaders);
        const tName = selectedTemplate ? selectedTemplate.name : 'Ad-hoc';

        // Build display headers without trailing [FileLabel] suffixes
        const displayHeaders = (tableHeaders || []).map(h => stripFileLabel(h));

        // Build header color metadata to preserve preview styling in saved report
        const headerSections = {};
        const headerColorClasses = {};
        const headerHexColors = {};
        // Capture live UI selections as a fallback in case the user didn't press Apply
        const uiSelections = (typeof getFileLevelSelectionsFromUI === 'function') ? getFileLevelSelectionsFromUI() : null;
        // Prefer explicit user assignments; otherwise infer from header content
        (tableHeaders || []).forEach((h, idx) => {
          const disp = displayHeaders[idx];
          const sec = (window.headerAssignments && window.headerAssignments[h]) || getSectionType(h);
          const cls = SECTION_COLORS[sec] || SECTION_COLORS.default;
          headerSections[disp] = sec;
          headerColorClasses[disp] = cls; // e.g. 'bg-blue-100'

          // Derive Hex color preference order:
          // 1) Explicit file-level selection (from UI Apply) -> window.__fileLevelSelections
          // 2) File info customColor (extractedData.fileInfo or window.fileInfo)
          // 3) Extracted Excel header color for this column (tableHeaderColors)
          // 4) No hex (fallback to class)
          try {
            const map = (typeof headerFileMap === 'object' && headerFileMap) ? headerFileMap : (window.headerFileMap || {});
            const fileIdx = map[h];
            let hex = '';
            // 1) Explicit per-file selection saved by Apply
            if (window.__fileLevelSelections && window.__fileLevelSelections[fileIdx] && window.__fileLevelSelections[fileIdx].color) {
              hex = window.__fileLevelSelections[fileIdx].color;
            // 1b) Fallback to current UI control state (no Apply pressed yet)
            } else if (uiSelections && uiSelections[fileIdx] && uiSelections[fileIdx].color) {
              hex = uiSelections[fileIdx].color;
            } else {
              // 2) fileInfo customColor (from processing or prior selections)
              const fi = (window.fileInfo || (extractedData && extractedData.fileInfo) || []);
              if (Array.isArray(fi) && fi[fileIdx] && fi[fileIdx].customColor) {
                hex = fi[fileIdx].customColor;
              // 3) Original Excel header color (if present)
              } else if (Array.isArray(tableHeaderColors) && tableHeaderColors[idx]) {
                hex = tableHeaderColors[idx];
              }
            }
            // Normalize to #RRGGBB if possible
            if (typeof hex === 'string' && hex) {
              // Convert ARGB like FFDBEAFE to #DBEAFE
              const m = hex.match(/^#?[0-9A-Fa-f]{6,8}$/);
              if (m) {
                const clean = hex.replace('#','');
                const rgb = clean.length === 8 ? clean.slice(2) : clean;
                headerHexColors[disp] = `#${rgb.toUpperCase()}`;
              } else if (/^#[0-9A-Fa-f]{6}$/.test(hex)) {
                headerHexColors[disp] = hex.toUpperCase();
              }
            }
          } catch(_) {}
        });

        const response = await axios.post('/api/reports/generate', {
          collegeId: currentCollegeId,
          reportData: { headers: displayHeaders, rows: tableData, meta: { headerSections, headerColorClasses, headerHexColors } },
          reportName: meta.name,
          summary: meta.summary,
          templateKey: tKey,
          templateName: tName
        });
        if (response.data && response.data.success) {
          showStatus('Report generated successfully', 'success');
          // Store current report as previous for future comparisons (rows expected)
          await storeCurrentReportAsPrevious(currentCollegeId, { headers: tableHeaders, rows: tableData }, tKey);
          try {
            const rpt = response.data.report;
            // Pass meta so Excel export can use saved colours
            await showReportSuccessDialog(meta.name, currentCollegeId, rpt?.id, displayHeaders, tableData, { headerSections, headerColorClasses, headerHexColors });
          } catch (_) {}
        } else {
          const err = response.data?.error || 'Unknown error';
          showStatus('Report generation failed: ' + err, 'error');
        }
      } catch (error) {
        console.error('Error generating report:', error);
        showStatus('Error generating report: ' + error.message, 'error');
      }
    }

    // Template functions
    function getSelectedTemplate() {
      const templateSelect = document.getElementById('templateSelect');
      if (!templateSelect || !templateSelect.value) return null;
      
      // Get template from global storage
      if (window.__templates && Array.isArray(window.__templates)) {
        const selectedId = templateSelect.value;
        const template = window.__templates.find(t => String(t.id) === String(selectedId));
        console.log('Selected template:', template);
        return template;
      }
      
      return null;
    }

    // Explicitly apply the currently selected template
    async function applySelectedTemplate() {
      try {
        const selectedTemplate = getSelectedTemplate();
        if (!selectedTemplate) {
          showStatus('Please select a template first', 'error');
          return;
        }
        showStatus(`Applying template "${selectedTemplate.name}"...`, 'info');

        if (selectedTemplate.headers) {
          tableHeaders = [...selectedTemplate.headers];
          // Prefer remapping to current uploads if available; otherwise preview saved rows
          if (Array.isArray(selectedTemplate.tableData) && selectedTemplate.tableData.length > 0) {
            tableData = selectedTemplate.tableData.map(row => [...row]);
            // Only use static preview if there is no processed data yet
            window.previewingTemplateRows = !(window.latestProcessedData && typeof window.latestProcessedData === 'object');
          } else {
            // No saved rows in the template; fall back to rebuilding from data
            window.previewingTemplateRows = false;
          }

          // Propagate headerFileMap and fileInfo for proper header coloring
          try {
            function synthesizeFileInfoFromMap(hmap) {
              const indices = new Set();
              Object.values(hmap || {}).forEach(v => { if (typeof v === 'number') indices.add(v); });
              const maxIdx = indices.size ? Math.max(...Array.from(indices)) : -1;
              const out = [];
              for (let i = 0; i <= maxIdx; i++) {
                out.push({ originalName: `File ${i + 1}`, filename: `file_${i+1}`, customColor: undefined, label: `File ${i + 1}` });
              }
              return out;
            }
            if (selectedTemplate.headerFileMap && typeof selectedTemplate.headerFileMap === 'object') {
              window.headerFileMap = { ...selectedTemplate.headerFileMap };
            } else {
              window.headerFileMap = {};
            }
            headerFileMap = window.headerFileMap;
            if (Array.isArray(selectedTemplate.fileInfo)) {
              window.fileInfo = [...selectedTemplate.fileInfo];
              try {
                if (window.__fileLevelSelections && Array.isArray(window.fileInfo)) {
                  Object.keys(window.__fileLevelSelections).forEach(k => {
                    const idx = parseInt(k); const sel = window.__fileLevelSelections[k];
                    if (!isNaN(idx) && window.fileInfo[idx]) {
                      if (sel && sel.color) window.fileInfo[idx].customColor = sel.color;
                      // Preserve activity types; only override when not an activity or when types match
                      try {
                        const origType = (window.fileInfo[idx].contentType || '').toLowerCase();
                        const newType = (sel && sel.type) ? String(sel.type).toLowerCase() : '';
                        const isActivity = origType === 'enrichment' || origType === 'employment' || origType === 'employer';
                        const matchesActivity = (isActivity && (newType === origType || (origType === 'employment' && newType === 'employer')));
                        if (!isActivity) {
                          if (newType) window.fileInfo[idx].contentType = newType;
                        } else if (matchesActivity) {
                          window.fileInfo[idx].contentType = (newType === 'employer') ? 'employment' : origType;
                        }
                      } catch(_) {}
                    }
                  });
                }
              } catch(_) {}
            } else if (Object.keys(window.headerFileMap).length > 0) {
              window.fileInfo = synthesizeFileInfoFromMap(window.headerFileMap);
            } else {
              window.fileInfo = [];
            }
            // Enforce strict template mode to keep column order and template colouring
            window.strictTemplateMode = true;
            window.useOriginalHeaders = false;

            // Update legend to reflect selected template file colors
            try {
              const legend = document.getElementById('fileLegend');
              if (legend && Array.isArray(window.fileInfo)) {
                legend.innerHTML = window.fileInfo.map((fi, idx) => {
                  const c = (fi && fi.customColor) ? fi.customColor : ['#1d4ed8', '#9333ea', '#059669', '#ea580c', '#dc2626', '#0ea5e9', '#f59e0b'][idx % 7];
                  const name = (fi && (fi.originalName || fi.filename)) ? (fi.originalName || fi.filename) : `File ${idx + 1}`;
                  return `<span style="display:inline-flex;align-items:center;margin-right:12px;margin-bottom:6px;">
                    <span style=\"display:inline-block;width:10px;height:10px;background:${c};border-radius:2px;margin-right:6px;\"></span>
                    <span style=\"font-size:12px;color:#374151;\">${name}</span>
                  </span>`;
                }).join('');
              }
            } catch (_) {}
          } catch (e) {
            console.warn('Failed to apply template metadata:', e?.message || e);
          }

          if (window.latestProcessedData && typeof window.latestProcessedData === 'object') {
            // Ensure we rebuild from current uploads
            try { window.previewingTemplateRows = false; } catch(_) {}
            try { await adaptTableToData(window.latestProcessedData, true); } catch (e) { console.warn('Remap after template apply failed:', e?.message || e); }
            showStatus(`Template "${selectedTemplate.name}" applied to current data`, 'success');
          } else {
            renderTable();
            showStatus(`Template "${selectedTemplate.name}" loaded for preview`, 'success');
          }
        }
      } catch (e) {
        console.warn('applySelectedTemplate failed:', e?.message || e);
        showStatus('Failed to apply template: ' + (e?.message || e), 'error');
      }
    }

    function getTemplateMode() {
      const templateMode = document.getElementById('templateMode');
      return templateMode ? templateMode.value : 'flexible';
    }

    // Modal form for renaming the selected template
    async function showRenameTemplateModal() {
      const selectedTemplate = getSelectedTemplate();
      if (!selectedTemplate) {
        showStatus('Please select a template to rename', 'error');
        return;
      }
      const overlay = document.createElement('div');
      overlay.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
      overlay.innerHTML = `
        <div class="bg-white rounded-lg p-6 max-w-md w-full mx-4 shadow-xl" id="renameTplModal">
          <h3 class="text-lg font-semibold mb-4">Rename Template</h3>
          <form id="renameTemplateForm" class="space-y-3">
            <div>
              <label class="block text-sm font-medium text-gray-700 mb-1">Template name</label>
              <input id="renameTemplateName" type="text" class="w-full border border-gray-300 rounded px-3 py-2" value="${(selectedTemplate.name || '').replace(/"/g, '&quot;')}">
            </div>
            <div>
              <label class="block text-sm font-medium text-gray-700 mb-1">Description (optional)</label>
              <input id="renameTemplateDescription" type="text" class="w-full border border-gray-300 rounded px-3 py-2" value="${(selectedTemplate.description || '').replace(/"/g, '&quot;')}">
            </div>
            <div class="flex justify-end gap-2 pt-2">
              <button id="renameTplCancel" type="button" class="px-4 py-2 rounded bg-gray-200 text-gray-800 hover:bg-gray-300">Cancel</button>
              <button id="renameTplSubmit" type="submit" class="px-4 py-2 rounded bg-blue-600 text-white hover:bg-blue-700">Save</button>
            </div>
          </form>
        </div>`;
      const cleanup = () => { try { document.body.removeChild(overlay); } catch(_) {} };
      overlay.addEventListener('click', (e) => { if (e.target === overlay) cleanup(); });
      document.body.appendChild(overlay);
      const contentEl = overlay.querySelector('#renameTplModal');
      if (contentEl) contentEl.addEventListener('click', (e) => e.stopPropagation());
      const form = overlay.querySelector('#renameTemplateForm');
      const nameInput = overlay.querySelector('#renameTemplateName');
      const descInput = overlay.querySelector('#renameTemplateDescription');
      const cancelBtn = overlay.querySelector('#renameTplCancel');
      if (cancelBtn) cancelBtn.addEventListener('click', cleanup);
      if (nameInput) nameInput.focus();
      if (form) {
        form.addEventListener('submit', async (ev) => {
          ev.preventDefault();
          const newName = (nameInput?.value || '').trim();
          const newDesc = (descInput?.value || '').trim();
          if (!newName) { showStatus('Please enter a template name', 'error'); return; }
          try {
            const headers = Array.isArray(selectedTemplate.headers) ? selectedTemplate.headers : [];
            const rows = Array.isArray(selectedTemplate.tableData) ? selectedTemplate.tableData : [];
            const payload = {
              name: newName,
              description: newDesc,
              headers,
              tableData: rows,
              columnCount: headers.length,
              rowCount: rows.length,
              headerFileMap: selectedTemplate.headerFileMap || {},
              fileInfo: Array.isArray(selectedTemplate.fileInfo) ? selectedTemplate.fileInfo : []
            };
            showStatus('Renaming template...', 'info');
            const res = await axios.put(`/api/templates/${selectedTemplate.id}`, payload, { withCredentials: true });
            if (!res.data || !res.data.success) throw new Error(res.data?.error || 'Rename failed');
            showStatus('Template renamed successfully', 'success');
            await loadTemplates();
            try { const sel = document.getElementById('templateSelect'); if (sel) sel.value = String(selectedTemplate.id); } catch(_) {}
            cleanup();
          } catch (e) {
            console.error('Rename template error:', e);
            showStatus('Failed to rename template: ' + (e?.message || e), 'error');
          }
        });
      }
    }

    // Update selected template structure from current table (headers + rows)
    async function updateSelectedTemplateFromTable() {
      try {
        const selectedTemplate = getSelectedTemplate();
        if (!selectedTemplate) {
          showStatus('Please select a template to update', 'error');
          return;
        }
        if (!Array.isArray(tableHeaders) || !Array.isArray(tableData) || tableHeaders.length === 0) {
          showStatus('No current table available. Upload/process data first.', 'error');
          return;
        }
        const confirmed = window.confirm('Update the selected template to match the current table (headers and rows)?');
        if (!confirmed) return;

        // Preserve exact headers including [FileLabel] and activity suffixes to keep per-file mapping unambiguous
        const displayHeaders = Array.isArray(tableHeaders) ? [...tableHeaders] : [];

        const payload = {
          name: selectedTemplate.name,
          description: selectedTemplate.description || '',
          headers: displayHeaders,
          tableData: tableData,
          columnCount: displayHeaders.length,
          rowCount: tableData.length,
          // Carry over any header/file mapping metadata used for colouring
          headerFileMap: (typeof window.headerFileMap === 'object' && window.headerFileMap) ? window.headerFileMap : (selectedTemplate.headerFileMap || {}),
          fileInfo: Array.isArray(window.fileInfo) ? window.fileInfo : (Array.isArray(selectedTemplate.fileInfo) ? selectedTemplate.fileInfo : [])
        };

        const id = selectedTemplate.id;
        showStatus('Updating template...', 'info');
        const res = await axios.put(`/api/templates/${id}`, payload, { withCredentials: true });
        if (res.data && res.data.success) {
          showStatus('Template updated successfully', 'success');
          await loadTemplates();
          try {
            const templateSelect = document.getElementById('templateSelect');
            if (templateSelect) templateSelect.value = String(id);
          } catch(_) {}
        } else {
          throw new Error(res.data?.error || 'Update failed');
        }
      } catch (e) {
        console.error('Update template error:', e);
        showStatus('Failed to update template: ' + (e?.message || e), 'error');
      }
    }

    async function showSaveTemplateModal() {
      if (!tableHeaders || !tableData || tableData.length === 0) {
        showStatus('No data available to save as template. Please upload files and generate data first.', 'error');
        return;
      }

      // Pull any pre-filled values from the form section (if present)
      const prefillNameInput = document.getElementById('templateName');
      const prefillDescInput = document.getElementById('templateDescription');
      const prefillName = prefillNameInput ? (prefillNameInput.value || '').trim() : '';
      const prefillDesc = prefillDescInput ? (prefillDescInput.value || '').trim() : '';

      // Build a modal (like the dashboard page) to avoid prompt flicker and accidental close
      const overlay = document.createElement('div');
      overlay.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
      overlay.innerHTML = `
        <div class="bg-white rounded-lg p-6 max-w-md w-full mx-4 shadow-xl" id="saveTplModalContent">
          <h3 class="text-lg font-semibold mb-4">Save Template</h3>
          <div class="mb-4 p-3 bg-blue-50 border border-blue-200 rounded-md text-sm text-blue-800">
            <div><strong>Headers:</strong> ${Array.isArray(tableHeaders) ? tableHeaders.length : 0}</div>
            <div><strong>Rows:</strong> ${Array.isArray(tableData) ? tableData.length : 0}</div>
          </div>
          <form id="inlineSaveTemplateForm" class="space-y-3">
            <div>
              <label class="block text-sm font-medium text-gray-700 mb-1">Template name</label>
              <input id="inlineTemplateName" type="text" class="w-full border border-gray-300 rounded px-3 py-2" placeholder="e.g., Monthly Report Template" value="${prefillName}">
            </div>
            <div>
              <label class="block text-sm font-medium text-gray-700 mb-1">Description (optional)</label>
              <input id="inlineTemplateDescription" type="text" class="w-full border border-gray-300 rounded px-3 py-2" placeholder="Brief description" value="${prefillDesc}">
            </div>
            <div class="flex justify-end gap-2 pt-2">
              <button id="inlineTplCancel" type="button" class="px-4 py-2 rounded bg-gray-200 text-gray-800 hover:bg-gray-300">Cancel</button>
              <button id="inlineTplSubmit" type="submit" class="px-4 py-2 rounded bg-blue-600 text-white hover:bg-blue-700">Save Template</button>
            </div>
          </form>
        </div>
      `;

      const cleanup = () => { try { document.body.removeChild(overlay); } catch (_) {} };
      // Close when clicking the dimmed area only
      overlay.addEventListener('click', (e) => { if (e.target === overlay) cleanup(); });

      document.body.appendChild(overlay);

      const contentEl = overlay.querySelector('#saveTplModalContent');
      if (contentEl) contentEl.addEventListener('click', (e) => e.stopPropagation());

      const form = overlay.querySelector('#inlineSaveTemplateForm');
      const nameInput = overlay.querySelector('#inlineTemplateName');
      const descInput = overlay.querySelector('#inlineTemplateDescription');
      const cancelBtn = overlay.querySelector('#inlineTplCancel');

      if (cancelBtn) cancelBtn.addEventListener('click', cleanup);
      if (nameInput) nameInput.focus();

      if (form) {
        form.addEventListener('submit', async (ev) => {
          ev.preventDefault();
          const templateName = (nameInput?.value || '').trim();
          const templateDescription = (descInput?.value || '').trim();
          if (!templateName) {
            showStatus('Please enter a template name', 'error');
            return;
          }

          showStatus('Saving template...', 'info');
          try {
            // Use display headers (without trailing [FileLabel]) for saved templates
            const displayHeaders = (tableHeaders || []).map(h => stripFileLabel(h));
            const templateData = {
              templateName,
              templateDescription,
              headers: displayHeaders,
              tableData: tableData,
              processedData: { 
                headers: displayHeaders, 
                data: tableData, 
                headerFileMap: (window.headerFileMap || headerFileMap || {}),
                fileInfo: Array.isArray(window.fileInfo) ? window.fileInfo : []
              }
            };

            const response = await axios.post('/api/create-template-from-preview', templateData);
            console.log('Template creation response:', response.data);

            if (response.data.success) {
              showStatus('Template saved successfully: ' + templateName, 'success');
              // Clear any pre-filled form fields on the page if they were set
              if (prefillNameInput) prefillNameInput.value = '';
              if (prefillDescInput) prefillDescInput.value = '';
              const templateFileInput = document.getElementById('templateFileInput');
              if (templateFileInput) templateFileInput.value = '';

              // Refresh templates list
              await loadTemplates();
              try {
                const tpl = response.data.template;
                if (tpl && tpl.id) {
                  const templateSelect = document.getElementById('templateSelect');
                  if (templateSelect) templateSelect.value = String(tpl.id);
                }
              } catch (_) {}
              cleanup();
            } else {
              showStatus('Failed to save template: ' + (response.data.error || 'Unknown error'), 'error');
            }
          } catch (error) {
            console.error('Template save error:', error);
            let errorMessage = 'Failed to save template';
            if (error?.response?.data?.error) {
              errorMessage += ': ' + error.response.data.error;
            } else {
              errorMessage += ': ' + (error.message || String(error));
            }
            showStatus(errorMessage, 'error');
          }
        });
      }
    }

    // Previous report data
    async function loadPreviousReportData(collegeId) {
      try {
        // Use templateKey for fetching the correct previous report
        const selectedTemplate = getSelectedTemplate();
        const tKey = selectedTemplate ? String(selectedTemplate.id) : computeHeaderSignature(tableHeaders);
        const response = await axios.get(`/api/previous-report/${collegeId}`, { params: { templateKey: tKey } });
        if (response.data.success && response.data.data) {
          previousReportData = response.data.data;
        } else {
          previousReportData = null;
        }
      } catch (error) {
        console.error('Error loading previous report data:', error);
        previousReportData = null;
      }
    }

    async function storeCurrentReportAsPrevious(collegeId, reportData, templateKey) {
      try {
        await axios.post(`/api/previous-report/${collegeId}`, { data: reportData, templateKey });
      } catch (error) {
        console.error('Error storing previous report data:', error);
      }
    }

    // Utility functions
    function showStatus(message, type = 'info') {
      const statusArea = document.getElementById('statusArea');
      if (!statusArea) return;
      
      const statusDiv = document.createElement('div');
      statusDiv.className = `p-4 rounded-lg shadow-lg mb-2 ${
        type === 'error' ? 'bg-red-500 text-white' :
        type === 'success' ? 'bg-green-500 text-white' :
        'bg-blue-500 text-white'
      }`;
      statusDiv.innerHTML = `
        <div class="flex justify-between items-center">
          <span>${message}</span>
          <button onclick="this.parentElement.parentElement.remove()" class="ml-4 text-white hover:text-gray-200">
            √ó
          </button>
        </div>
      `;
      
      statusArea.appendChild(statusDiv);
      
      setTimeout(() => {
        if (statusDiv.parentElement) {
          statusDiv.remove();
        }
      }, 5000);
    }

    // Non-blocking, reliable confirm dialog that does not get closed by page rerenders
    function showConfirmDialog(message) {
      return new Promise((resolve) => {
        try {
          const modal = document.createElement('div');
          modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
          modal.innerHTML = `
            <div class="bg-white rounded-lg p-6 max-w-md w-full mx-4 shadow-xl">
              <h3 class="text-lg font-semibold mb-3">Confirm</h3>
              <p class="text-sm text-gray-700 mb-5">${message}</p>
              <div class="flex justify-end gap-2">
                <button id="confirmCancelBtn" type="button" class="px-4 py-2 rounded bg-gray-200 text-gray-800 hover:bg-gray-300">Cancel</button>
                <button id="confirmOkBtn" type="button" class="px-4 py-2 rounded bg-red-600 text-white hover:bg-red-700">Delete</button>
              </div>
            </div>`;
          const cleanup = (value) => {
            try { document.body.removeChild(modal); } catch (_) {}
            resolve(value);
          };
          modal.addEventListener('click', (e) => { if (e.target === modal) cleanup(false); });
          document.body.appendChild(modal);
          const ok = modal.querySelector('#confirmOkBtn');
          const cancel = modal.querySelector('#confirmCancelBtn');
          if (ok) ok.addEventListener('click', () => cleanup(true));
          if (cancel) cancel.addEventListener('click', () => cleanup(false));
          // Keyboard support
          const onKey = (e) => {
            if (e.key === 'Escape') { e.preventDefault(); cleanup(false); window.removeEventListener('keydown', onKey, true); }
            if (e.key === 'Enter')  { e.preventDefault(); cleanup(true);  window.removeEventListener('keydown', onKey, true); }
          };
          window.addEventListener('keydown', onKey, true);
        } catch (_) {
          // Fallback
          resolve(window.confirm(message));
        }
      });
    }

    function logout() {
      axios.post('/api/auth/logout')
        .then(() => {
          window.location.href = '/login';
        })
        .catch(() => {
          window.location.href = '/login';
        });
    }

    // Collect report meta (name + summary) via in-page modal
    function showReportMetaDialog(defaultName = 'Generated Report', defaultSummary = '') {
      return new Promise((resolve) => {
        const modal = document.createElement('div');
        modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
        modal.innerHTML = `
          <div class="bg-white rounded-lg p-6 max-w-lg w-full mx-4 shadow-xl">
            <h3 class="text-lg font-semibold mb-4">Finalize Report</h3>
            <div class="space-y-3">
              <div>
                <label class="block text-sm font-medium text-gray-700 mb-1">Report name</label>
                <input id="reportNameInput" type="text" class="w-full border border-gray-300 rounded px-3 py-2" value="${defaultName}">
              </div>
              <div>
                <label class="block text-sm font-medium text-gray-700 mb-1">Summary (optional)</label>
                <textarea id="reportSummaryInput" rows="3" class="w-full border border-gray-300 rounded px-3 py-2" placeholder="Add a short description...">${defaultSummary}</textarea>
              </div>
            </div>
            <div class="flex justify-end gap-2 mt-5">
              <button id="reportCancelBtn" type="button" class="px-4 py-2 rounded bg-gray-200 text-gray-800 hover:bg-gray-300">Cancel</button>
              <button id="reportOkBtn" type="button" class="px-4 py-2 rounded bg-green-600 text-white hover:bg-green-700">Generate</button>
            </div>
          </div>`;
        document.body.appendChild(modal);
        const cleanup = (val) => { try { document.body.removeChild(modal); } catch(_) {} resolve(val); };
        modal.addEventListener('click', (e) => { if (e.target === modal) cleanup(null); });
        const ok = modal.querySelector('#reportOkBtn');
        const cancel = modal.querySelector('#reportCancelBtn');
        const nameInput = modal.querySelector('#reportNameInput');
        const summaryInput = modal.querySelector('#reportSummaryInput');
        const submit = () => {
          const name = (nameInput.value || '').trim() || defaultName;
          const summary = (summaryInput.value || '').trim();
          cleanup({ name, summary });
        };
        if (ok) ok.addEventListener('click', submit);
        if (cancel) cancel.addEventListener('click', () => cleanup(null));
        const onKey = (e) => {
          if (e.key === 'Escape') { e.preventDefault(); cleanup(null); window.removeEventListener('keydown', onKey, true); }
          if (e.key === 'Enter')  { e.preventDefault(); submit();      window.removeEventListener('keydown', onKey, true); }
        };
        window.addEventListener('keydown', onKey, true);
        nameInput && nameInput.focus();
      });
    }

    // ===== EDITING FUNCTIONS =====
    
    // Add column functionality
    function addColumn() {
      const columnName = prompt('Enter column name:');
      if (!columnName) return;
      
      // Add to headers
      tableHeaders.push(columnName);
      
      // Add empty values to all rows
      tableData.forEach(row => {
        row.push('');
      });
      
      // Re-render table
      renderTable();
      showStatus('Column added successfully', 'success');
    }
    
    // Delete column functionality
    function deleteColumn() {
      try {
        if (!Array.isArray(tableHeaders) || tableHeaders.length === 0) {
          showStatus('No columns to delete', 'error');
          return;
        }
        // Prefer deleting currently selected column(s) when in Edit mode
        let colsToDelete = [];
        if (editMode) {
          if (selectedColumns && selectedColumns.size > 0) {
            colsToDelete = Array.from(selectedColumns).map(v => typeof v === 'number' ? v : tableHeaders.indexOf(v));
          }
          if (typeof lastSelectedColIndex === 'number' && !isNaN(lastSelectedColIndex)) {
            colsToDelete.push(lastSelectedColIndex);
          }
          colsToDelete = Array.from(new Set(colsToDelete)).filter(i => i >= 0 && i < tableHeaders.length);
        }

        // Fallback to manual prompt if nothing is selected
        if (colsToDelete.length === 0) {
          const columnIndex = prompt('Enter column index to delete (0-' + (tableHeaders.length - 1) + '):');
          if (columnIndex === null) return;
          const idx = parseInt(columnIndex);
          if (isNaN(idx) || idx < 0 || idx >= tableHeaders.length) {
            showStatus('Invalid column index', 'error');
            return;
          }
          colsToDelete = [idx];
        }

        // Prevent deleting all columns
        if (colsToDelete.length >= tableHeaders.length) {
          showStatus('Cannot delete all columns', 'error');
          return;
        }

        // Delete in descending order to keep indices stable
        colsToDelete.sort((a, b) => b - a).forEach(idx => {
          tableHeaders.splice(idx, 1);
          tableData.forEach(r => r.splice(idx, 1));
        });

        // Reset selection
        selectedColumns = new Set();
        lastSelectedColIndex = null;

        renderTable();
        showStatus(`Deleted ${colsToDelete.length} column(s)`, 'success');
      } catch (e) {
        console.warn('deleteColumn failed:', e?.message || e);
        showStatus('Delete column failed: ' + (e?.message || e), 'error');
      }
    }
    
    // Add row functionality
    function addRow() {
      // Create new row with empty values
      const newRow = new Array(tableHeaders.length).fill('');
      tableData.push(newRow);
      
      // Re-render table
      renderTable();
      showStatus('Row added successfully', 'success');
    }
    
    // Delete row functionality
    function deleteRow() {
      if (tableData.length <= 1) {
        showStatus('Cannot delete the last row', 'error');
        return;
      }
      
      const rowIndex = prompt('Enter row index to delete (0-' + (tableData.length - 1) + '):');
      if (rowIndex === null) return;
      
      const index = parseInt(rowIndex);
      if (isNaN(index) || index < 0 || index >= tableData.length) {
        showStatus('Invalid row index', 'error');
        return;
      }
      
      // Remove row
      tableData.splice(index, 1);
      
      // Re-render table
      renderTable();
      showStatus('Row deleted successfully', 'success');
    }
    
    // Move column left/right functionality
    function moveColumnLeft() {
      if (!Array.isArray(tableHeaders) || tableHeaders.length < 2) return;
      let i = lastSelectedColIndex;
      if ((i === null || i === undefined) && selectedColumns && selectedColumns.size > 0) {
        // Convert selected header keys to indices
        const idxs = Array.from(selectedColumns)
          .map(k => tableHeaders.indexOf(k))
          .filter(v => v >= 0);
        if (idxs.length) i = Math.min(...idxs);
      }
      if (typeof i !== 'number' || isNaN(i)) {
        showStatus('Select a column (click a header or tick a checkbox) first', 'error');
        return;
      }
      if (i <= 0) return; // already at leftmost
      // swap headers
      [tableHeaders[i - 1], tableHeaders[i]] = [tableHeaders[i], tableHeaders[i - 1]];
      // swap cells in each row
      tableData.forEach(r => { [r[i - 1], r[i]] = [r[i], r[i - 1]]; });
      lastSelectedColIndex = i - 1;
      selectedColumns = new Set();
      renderTable();
    }
    function moveColumnRight() {
      if (!Array.isArray(tableHeaders) || tableHeaders.length < 2) return;
      let i = lastSelectedColIndex;
      if ((i === null || i === undefined) && selectedColumns && selectedColumns.size > 0) {
        const idxs = Array.from(selectedColumns)
          .map(k => tableHeaders.indexOf(k))
          .filter(v => v >= 0);
        if (idxs.length) i = Math.min(...idxs);
      }
      if (typeof i !== 'number' || isNaN(i)) {
        showStatus('Select a column (click a header or tick a checkbox) first', 'error');
        return;
      }
      if (i >= tableHeaders.length - 1) return; // rightmost
      [tableHeaders[i + 1], tableHeaders[i]] = [tableHeaders[i], tableHeaders[i + 1]];
      tableData.forEach(r => { [r[i + 1], r[i]] = [r[i], r[i + 1]]; });
      lastSelectedColIndex = i + 1;
      selectedColumns = new Set();
      renderTable();
    }
    
    // Move row up/down functionality
    function moveRowUp() {
      if (!Array.isArray(tableData) || tableData.length < 2) return;
      let i = lastSelectedRowIndex;
      if (i === null || i === undefined) {
        if (selectedRows && selectedRows.size > 0) {
          i = Math.min(...Array.from(selectedRows));
        }
      }
      if (typeof i !== 'number' || isNaN(i)) {
        showStatus('Select a row (click a cell or tick a checkbox) first', 'error');
        return;
      }
      if (i <= 0) return;
      [tableData[i - 1], tableData[i]] = [tableData[i], tableData[i - 1]];
      lastSelectedRowIndex = i - 1;
      selectedRows = new Set();
      renderTable();
    }
    function moveRowDown() {
      if (!Array.isArray(tableData) || tableData.length < 2) return;
      let i = lastSelectedRowIndex;
      if (i === null || i === undefined) {
        if (selectedRows && selectedRows.size > 0) {
          i = Math.min(...Array.from(selectedRows));
        }
      }
      if (typeof i !== 'number' || isNaN(i)) {
        showStatus('Select a row (click a cell or tick a checkbox) first', 'error');
        return;
      }
      if (i >= tableData.length - 1) return;
      [tableData[i + 1], tableData[i]] = [tableData[i], tableData[i + 1]];
      lastSelectedRowIndex = i + 1;
      selectedRows = new Set();
      renderTable();
    }
    
    // Delete all currently selected rows and columns
    async function deleteSelectedItems() {
      try {
        if (!editMode) {
          showStatus('Turn on Editing to delete selected items', 'error');
          return;
        }
        // Collect selected column indices from header keys
        let colIdxs = [];
        if (selectedColumns && selectedColumns.size > 0) {
          colIdxs = Array.from(selectedColumns)
            .map(k => (typeof k === 'number' ? k : tableHeaders.indexOf(k)))
            .filter(i => i >= 0);
        }
        if (typeof lastSelectedColIndex === 'number' && !isNaN(lastSelectedColIndex)) {
          colIdxs.push(lastSelectedColIndex);
        }
        // Collect selected row indices
        let rowIdxs = selectedRows ? Array.from(selectedRows) : [];
        if (typeof lastSelectedRowIndex === 'number' && !isNaN(lastSelectedRowIndex)) {
          rowIdxs.push(lastSelectedRowIndex);
        }
        // Unique and sort descending for safe splicing
        const uniqueCols = Array.from(new Set(colIdxs))
          .filter(i => i >= 0 && i < tableHeaders.length)
          .sort((a, b) => b - a);
        const uniqueRows = Array.from(new Set(rowIdxs))
          .filter(i => i >= 0 && i < tableData.length)
          .sort((a, b) => b - a);
        if (uniqueCols.length === 0 && uniqueRows.length === 0) {
          showStatus('No rows or columns selected to delete', 'error');
          return;
        }
        const ok = await showConfirmDialog(`Delete ${uniqueCols.length} column(s) and ${uniqueRows.length} row(s)? This cannot be undone.`);
        if (!ok) return;
        // Delete columns first
        uniqueCols.forEach(idx => {
          tableHeaders.splice(idx, 1);
          tableData.forEach(r => r.splice(idx, 1));
        });
        // Delete rows
        uniqueRows.forEach(idx => {
          tableData.splice(idx, 1);
        });
        // Reset selections
        selectedColumns = new Set();
        selectedRows = new Set();
        lastSelectedColIndex = null;
        lastSelectedRowIndex = null;
        renderTable();
        showStatus('Deleted selected items', 'success');
      } catch (e) {
        console.warn('deleteSelectedItems failed:', e?.message || e);
        showStatus('Delete failed: ' + (e?.message || e), 'error');
      }
    }
    
    // Enhanced save template functionality
    async function saveTemplate() {
      const templateName = prompt('Enter template name:');
      if (!templateName) return;
      
      try {
        const response = await axios.post('/api/save-template', {
          name: templateName,
          headers: tableHeaders,
          tableData: tableData,
          type: 'custom'
        });
        
        if (response.data.success) {
          showStatus('Template saved successfully', 'success');
          // Immediately refresh templates and select the newly saved one
          try {
            await loadTemplates();
            const tpl = response.data.template;
            if (tpl && tpl.id) {
              const templateSelect = document.getElementById('templateSelect');
              if (templateSelect) templateSelect.value = String(tpl.id);
            }
          } catch (e) {
            console.warn('Template refresh after save failed:', e?.message || e);
          }
        } else {
          showStatus('Error saving template: ' + response.data.error, 'error');
        }
      } catch (error) {
        showStatus('Error saving template: ' + error.message, 'error');
      }
    }
    
    // Cell editing functionality
    function setupCellEditing() {
      // Add event listeners for editable cells
      document.addEventListener('click', function(e) {
        if (e.target.classList.contains('editable-cell')) {
          e.target.focus();
        }
      });
      
      // Handle cell content changes
      document.addEventListener('blur', function(e) {
        if (e.target.classList.contains('editable-cell')) {
          const row = parseInt(e.target.dataset.row);
          const col = parseInt(e.target.dataset.col);
          const newValue = e.target.textContent.trim();
          
          if (row >= 0 && col >= 0 && row < tableData.length && col < tableHeaders.length) {
            tableData[row][col] = newValue;
            showStatus('Cell updated', 'info');
          }
        }
      }, true);
      
      // Handle Enter key to save and move to next cell
      document.addEventListener('keydown', function(e) {
        if (e.target.classList.contains('editable-cell') && e.key === 'Enter') {
          e.preventDefault();
          e.target.blur();
          
          // Find next editable cell
          const currentCell = e.target;
          const nextCell = currentCell.parentElement.nextElementSibling?.querySelector('.editable-cell') ||
                          currentCell.parentElement.parentElement.nextElementSibling?.querySelector('.editable-cell');
          
          if (nextCell) {
            nextCell.focus();
          }
        }
      });
    }
    
    // Toggle edit mode programmatically
    function toggleEditMode(force) {
      try {
        if (typeof force === 'boolean') {
          editMode = force;
        } else {
          editMode = !editMode;
        }
        const editControls = document.getElementById('editControls');
        const editToggleBtn = document.getElementById('editToggleBtn');
        console.log('toggleEditMode ->', { editMode, editControls: !!editControls, btn: !!editToggleBtn });
        if (editControls) {
          editControls.classList.toggle('hidden', !editMode);
          // Fallback to inline style to guarantee visibility
          editControls.style.display = editMode ? 'flex' : 'none';
        }
        if (editToggleBtn) editToggleBtn.textContent = editMode ? '‚úÖ Editing On' : '‚úèÔ∏è Add & Edit';
        renderTable();
      } catch (e) {
        console.warn('toggleEditMode failed:', e?.message || e);
      }
    }
    
    // Initialize editing functionality
    function initializeEditing() {
      // Add event listeners for editing buttons (guard each in case elements are absent)
      const btnAddCol = document.getElementById('addColumnBtn');
      if (btnAddCol) btnAddCol.addEventListener('click', addColumn);
      const btnDelCol = document.getElementById('deleteColumnBtn');
      if (btnDelCol) btnDelCol.addEventListener('click', deleteColumn);
      const btnAddRow = document.getElementById('addRowBtn');
      if (btnAddRow) btnAddRow.addEventListener('click', addRow);
      const btnDelRow = document.getElementById('deleteRowBtn');
      if (btnDelRow) btnDelRow.addEventListener('click', deleteRow);
      const btnDeleteSelected = document.getElementById('deleteSelectedBtn');
      if (btnDeleteSelected) btnDeleteSelected.addEventListener('click', deleteSelectedItems);
      const btnColLeft = document.getElementById('moveColLeftBtn');
      if (btnColLeft) btnColLeft.addEventListener('click', moveColumnLeft);
      const btnColRight = document.getElementById('moveColRightBtn');
      if (btnColRight) btnColRight.addEventListener('click', moveColumnRight);
      const btnRowUp = document.getElementById('moveRowUpBtn');
      if (btnRowUp) btnRowUp.addEventListener('click', moveRowUp);
      const btnRowDown = document.getElementById('moveRowDownBtn');
      if (btnRowDown) btnRowDown.addEventListener('click', moveRowDown);

      const editToggleBtn = document.getElementById('editToggleBtn');
      const editControls = document.getElementById('editControls');
      if (editToggleBtn && editControls) {
        // Avoid double-binding by removing any prior anonymous listener via cloning technique
        const freshBtn = editToggleBtn.cloneNode(true);
        // Ensure no inline onclick remains on the cloned button
        try { freshBtn.removeAttribute('onclick'); } catch(_) {}
        editToggleBtn.parentNode.replaceChild(freshBtn, editToggleBtn);
        // Delegate to the single source of truth
        freshBtn.addEventListener('click', () => {
          toggleEditMode();
        });
      }
      
      // Ensure save template button opens the template save flow
      const saveTemplateBtn = document.getElementById('saveTemplateBtn');
      if (saveTemplateBtn) {
        // Avoid double-binding by resetting then binding the correct handler
        try { saveTemplateBtn.replaceWith(saveTemplateBtn.cloneNode(true)); } catch(_) {}
      }
      const freshSaveBtn = document.getElementById('saveTemplateBtn');
      if (freshSaveBtn) {
        freshSaveBtn.addEventListener('click', showSaveTemplateModal);
      }
      
      // Setup cell editing
      setupCellEditing();
    }
    
    // File type selection functions
    function showFileTypeSelection(files) {
      const fileTypeSelection = document.getElementById('fileTypeSelection');
      const fileTypeList = document.getElementById('fileTypeList');
      
      if (!files || files.length === 0) {
        fileTypeSelection.classList.add('hidden');
        return;
      }
      
      // Clear previous selections
      fileTypeList.innerHTML = '';
      
      // Create file type selection for each file
      Array.from(files).forEach((file, index) => {
        const fileDiv = document.createElement('div');
        fileDiv.className = 'flex items-center gap-3 p-2 bg-gray-50 rounded border';
        fileDiv.innerHTML = `
          <span class="text-sm font-medium text-gray-700 min-w-0 flex-1 truncate" title="${file.name}">${file.name}</span>
          <select class="file-type-select border border-gray-300 rounded px-2 py-1 text-sm" data-file-index="${index}">
            <option value="">Select type...</option>
            <option value="placements">Placements</option>
            <option value="employment">Employer Engagement</option>
            <option value="enrichment">Enrichment</option>
            <option value="careers">Careers</option>
            <option value="assessments">Assessments</option>
            <option value="targets">Targets</option>
            <option value="login">Login Data</option>
            <option value="default">Default</option>
          </select>
          <input type="color" class="file-color-select border border-gray-300 rounded px-1 py-1 text-sm" data-file-index="${index}" value="#dbeafe" title="Choose colour">
        `;
        fileTypeList.appendChild(fileDiv);
        
        // Add event listener to update colour when type changes
        const select = fileDiv.querySelector('.file-type-select');
        const colorInput = fileDiv.querySelector('.file-color-select');
        
        const defaultColors = {
          'placements': '#dbeafe',    // Blue
          'employment': '#f3e8ff',    // Purple
          'enrichment': '#ccfbf1',    // Teal
          'careers': '#fef3c7',       // Yellow
          'assessments': '#bbf7d0',   // Green
          'targets': '#fce7f3',       // Pink
          'login': '#e0e7ff',         // Indigo
          'default': '#f3f4f6'        // Gray
        };
        
        select.addEventListener('change', function() {
          const selectedType = this.value;
          if (selectedType && defaultColors[selectedType]) {
            colorInput.value = defaultColors[selectedType];
          }
        });
      });
      
      fileTypeSelection.classList.remove('hidden');
    }
    
    function getFileTypeSelections() {
      const selects = document.querySelectorAll('.file-type-select');
      const colorInputs = document.querySelectorAll('.file-color-select');
      const selections = {};
      
      for (const select of selects) {
        const fileIndex = parseInt(select.dataset.fileIndex);
        const fileType = select.value;
        
        if (!fileType) {
          return null; // Not all files have types selected
        }
        
        // Get the custom colour for this file
        const colorInput = document.querySelector(`.file-color-select[data-file-index="${fileIndex}"]`);
        const customColor = colorInput ? colorInput.value : '#dbeafe';
        
        selections[fileIndex] = {
          type: fileType,
          color: customColor
        };
      }
      
      return selections;
    }
    
    // Template file type selection functions
    function showTemplateFileTypeSelection(files) {
      const fileTypeSelection = document.getElementById('templateFileTypeSelection');
      const fileTypeList = document.getElementById('templateFileTypeList');
      
      if (!fileTypeSelection || !fileTypeList || !files || files.length === 0) {
        if (fileTypeSelection) fileTypeSelection.classList.add('hidden');
        return;
      }
      
      // Clear previous selections
      fileTypeList.innerHTML = '';
      
      // Create file type selection for each file
      Array.from(files).forEach((file, index) => {
        const fileDiv = document.createElement('div');
        fileDiv.className = 'flex items-center gap-3 p-2 bg-yellow-50 rounded border border-yellow-200';
        fileDiv.innerHTML = `
          <span class="text-sm font-medium text-yellow-800 min-w-0 flex-1 truncate" title="${file.name}">${file.name}</span>
          <select class="template-file-type-select border border-yellow-300 rounded px-2 py-1 text-sm" data-file-index="${index}">
            <option value="">Select type...</option>
            <option value="placements">Placements (Blue)</option>
            <option value="employer">Employer Engagement (Purple)</option>
            <option value="enrichment">Enrichment (Teal)</option>
            <option value="careers">Careers (Yellow)</option>
            <option value="assessments">Assessments (Green)</option>
            <option value="targets">Targets (Pink)</option>
            <option value="login">Login Data (Indigo)</option>
            <option value="default">Default (Gray)</option>
          </select>
          <input type="color" class="template-file-color-select w-8 h-8 border border-yellow-300 rounded cursor-pointer" data-file-index="${index}" value="#dbeafe" title="Choose custom colour">
        `;
        fileTypeList.appendChild(fileDiv);
      });
      
      // Add event listeners to update colour picker when file type changes
      const selects = document.querySelectorAll('.template-file-type-select');
      selects.forEach(select => {
        const colorInput = document.querySelector(`.template-file-color-select[data-file-index="${select.dataset.fileIndex}"]`);
        
        const defaultColors = {
          'placements': '#dbeafe',    // Blue
          'employer': '#f3e8ff',      // Purple
          'enrichment': '#ccfbf1',    // Teal
          'careers': '#fef3c7',       // Yellow
          'assessments': '#bbf7d0',   // Green
          'targets': '#fce7f3',       // Pink
          'login': '#e0e7ff',         // Indigo
          'default': '#f3f4f6'        // Gray
        };
        
        select.addEventListener('change', function() {
          const selectedType = this.value;
          if (selectedType && defaultColors[selectedType]) {
            colorInput.value = defaultColors[selectedType];
          }
        });
      });
      
      fileTypeSelection.classList.remove('hidden');
    }
    
    function getTemplateFileTypeSelections() {
      const selects = document.querySelectorAll('.template-file-type-select');
      const colorInputs = document.querySelectorAll('.template-file-color-select');
      
      if (selects.length === 0) {
        return null;
      }
      const selections = {};
      
      for (const select of selects) {
        const fileIndex = parseInt(select.dataset.fileIndex);
        const fileType = select.value;
        
        if (!fileType) {
          return null; // Not all files have types selected
        }
        
        // Get the custom colour for this file
        const colorInput = document.querySelector(`.template-file-color-select[data-file-index="${fileIndex}"]`);
        const customColor = colorInput ? colorInput.value : '#dbeafe';
        
        selections[fileIndex] = {
          type: fileType,
          color: customColor
        };
      }
      
      return selections;
    }
    
    // Add event listeners for file input changes
    document.addEventListener('DOMContentLoaded', function() {
      const fileInput = document.getElementById('fileInput');
      if (fileInput) {
        // No longer showing per-file type dropdowns on upload; assignments are handled in Step 2 by file.
        fileInput.addEventListener('change', function(e) { /* no-op */ });
      }
      
    });

    // Header assignment functionality
    let headerAssignments = {}; // Store header to section assignments
    
    const sectionConfig = {
      'placements': { color: 'bg-blue-100', name: 'Placements' },
      'employer': { color: 'bg-purple-100', name: 'Employer Engagement' },
      'enrichment': { color: 'bg-teal-100', name: 'Enrichment Activities' },
      'activities-combined': { color: 'bg-lime-100', name: 'Activities Combined KC' },
      'assessments': { color: 'bg-green-200', name: 'Assessments' },
      'careers': { color: 'bg-yellow-100', name: 'Careers' },
      'targets': { color: 'bg-pink-100', name: 'Targets' },
      'login': { color: 'bg-indigo-100', name: 'Login' },
      'default': { color: 'bg-gray-100', name: 'Other/Default' }
    };
    
    function showHeaderAssignmentInterface(headers) {
      console.log('Showing header assignment interface with headers:', headers);
      
      // Hide legacy file type selection (only if present)
      try {
        const fts = document.getElementById('fileTypeSelection');
        if (fts) fts.classList.add('hidden');
      } catch(_) {}
      
      // Show manual assignment section
      const assignmentSection = document.getElementById('headerAssignmentSection');
      assignmentSection.classList.remove('hidden');
      
      
      // Populate headers list
      const headersList = document.getElementById('headersList');
      headersList.innerHTML = '';
      
      // Build file-level assignment UI (uses extractedData.fileInfo)
      try {
        buildFileAssignmentsUI();
      } catch (e) {
        console.warn('Failed to build file assignments UI:', e?.message || e);
      }
      
      // Sort headers by original file upload order using extractedData.headerFileMap (file index)
      // Keep original intra-file order stable
      let sortedHeaders = Array.isArray(headers) ? headers.slice() : [];
      try {
        if (extractedData && extractedData.headerFileMap && extractedData.fileInfo) {
          const map = extractedData.headerFileMap;
          sortedHeaders = sortedHeaders
            .map((h, i) => ({ h, i, fileIdx: (map[h] !== undefined ? map[h] : Number.MAX_SAFE_INTEGER) }))
            .sort((a, b) => (a.fileIdx - b.fileIdx) || (a.i - b.i))
            .map(o => o.h);
        }
      } catch (e) {
        console.warn('Header sort by file order failed, using original order:', e?.message || e);
      }
      
      if (sortedHeaders && sortedHeaders.length > 0) {
        // Helper to resolve file index and accent color for a header
        const resolveFileIdx = (h) => {
          try {
            if (!extractedData || !extractedData.headerFileMap) return undefined;
            const map = extractedData.headerFileMap;
            if (map[h] !== undefined) return map[h];
            const base = h.replace(/ \+\/-?$/, '').replace(/ \(.*\)$/, '');
            for (const k in map) { if (k === base || k.startsWith(base + ' (')) return map[k]; }
          } catch(_) {}
          return undefined;
        };
        const getAccent = (idx) => {
          if (idx === undefined) return null;
          const palette = ['#1d4ed8', '#9333ea', '#059669', '#ea580c', '#dc2626', '#0ea5e9', '#f59e0b'];
          try {
            const fi = extractedData && extractedData.fileInfo ? extractedData.fileInfo[idx] : null;
            return (fi && fi.customColor) ? fi.customColor : palette[idx % palette.length];
          } catch(_) { return palette[idx % palette.length]; }
        };

        sortedHeaders.forEach((header, index) => {
          if (header && header.trim() !== '') {
            const fileIdx = resolveFileIdx(header);
            const accent = getAccent(fileIdx);
            const headerDiv = document.createElement('div');
            headerDiv.className = 'header-item p-3 border border-gray-300 rounded-lg cursor-pointer hover:bg-gray-50 transition-colors';
            headerDiv.dataset.header = header;
            // Compute display name with section suffix so activity tables are distinguishable
            let baseName = stripFileLabel(header);
            try {
              let t = getContentTypeForHeader(header);
              // If not resolved via mapping, infer from current file selection
              if ((!t || t === 'default' || t === 'activities') && Array.isArray(window.fileInfo) && fileIdx !== undefined) {
                const ft = (window.fileInfo[fileIdx] && window.fileInfo[fileIdx].contentType) ? String(window.fileInfo[fileIdx].contentType).toLowerCase() : '';
                t = ft || t;
              }
              const hasSuffix = /(Employer Engagement|Enrichment)/i.test(baseName);
              if (!hasSuffix) {
                if (t === 'employment' || t === 'employer') baseName += ' (Employer Engagement)';
                else if (t === 'enrichment') baseName += ' (Enrichment)';
              }
            } catch(_) {}
            headerDiv.innerHTML = `
              <div class="font-medium text-sm text-gray-800 mb-1">
                ${accent ? `<span class="file-accent-dot" data-file-idx="${fileIdx !== undefined ? fileIdx : ''}" style="display:inline-block;width:8px;height:8px;background:${accent};border-radius:2px;margin-right:6px;vertical-align:middle;"></span>` : ''}
                ${baseName}
              </div>
              <div class="text-xs text-gray-500 assignment-status">Click to assign</div>
            `;
            
            headerDiv.addEventListener('click', () => showSectionAssignmentModal(header));
            headersList.appendChild(headerDiv);
          }
        });
      } else {
        headersList.innerHTML = '<p class="text-gray-500 text-sm col-span-full">No headers found in uploaded files.</p>';
      }
    }

    // Build per-file assignment rows allowing user to set section and colour once per file
    function buildFileAssignmentsUI() {
      const container = document.getElementById('fileAssignments');
      if (!container) return;
      container.innerHTML = '';
      const fi = (extractedData && Array.isArray(extractedData.fileInfo)) ? extractedData.fileInfo : [];
      if (!fi.length) {
        container.innerHTML = '<div class="text-xs text-gray-500">No file information available.</div>';
        return;
      }
      // Top actions bar with Clear button
      const actions = document.createElement('div');
      actions.className = 'flex items-center justify-between mb-2';
      actions.innerHTML = `
        <div class="text-xs text-gray-600">Assign headers by file</div>
        <button id="clearFileSelectionsBtn" class="text-xs px-2 py-1 border border-gray-300 rounded">Clear saved colors</button>
      `;
      container.appendChild(actions);
      const defaultColors = {
        'placements': '#dbeafe',
        'employer': '#f3e8ff',
        'enrichment': '#ccfbf1',
        'careers': '#fef3c7',
        'assessments': '#bbf7d0',
        'activities-combined': '#ecfccb',
        'targets': '#fce7f3',
        'login': '#e0e7ff',
        'default': '#f3f4f6'
      };
      fi.forEach((info, idx) => {
        const row = document.createElement('div');
        row.className = 'flex items-center gap-3 bg-white border border-gray-200 rounded p-2';
        const displayName = info.originalName || info.filename || `File ${idx + 1}`;
        const color = info.customColor || '#dbeafe';
        const inferredType = (info.contentType && typeof info.contentType === 'string') ? info.contentType.toLowerCase() : 'default';
        row.innerHTML = `
          <div class="flex-1 text-sm text-gray-800 truncate" title="${displayName}">
            <span class="inline-block w-2.5 h-2.5 mr-2 align-middle rounded" style="background:${color}"></span>
            ${displayName}
          </div>
          <select class="file-assignment-type border border-gray-300 rounded px-2 py-1 text-sm" data-file-index="${idx}">
            <option value="placements">Placements</option>
            <option value="employer">Employer Engagement</option>
            <option value="enrichment">Enrichment</option>
            <option value="careers">Careers</option>
            <option value="assessments">Assessments</option>
            <option value="activities-combined">Activities Combined KC</option>
            <option value="targets">Targets</option>
            <option value="login">Login</option>
            <option value="default">Default</option>
          </select>
          <input type="color" class="file-assignment-color w-8 h-8 border border-gray-300 rounded cursor-pointer" data-file-index="${idx}" value="${defaultColors[inferredType] || color}" title="Choose custom colour" />
          <button class="use-default-color text-xs px-2 py-1 border border-gray-300 rounded" data-file-index="${idx}">Default colour</button>
          <button class="apply-file-assignment bg-green-600 text-white px-3 py-1 rounded text-sm" data-file-index="${idx}">Apply</button>
        `;
        container.appendChild(row);
        // Set initial select value after append
        const select = row.querySelector('.file-assignment-type');
        if (select) select.value = (inferredType === 'employer' || inferredType === 'employment') ? 'employer' : inferredType;

        // Prefill from any saved selections to persist user choices across sessions
        try {
          if (window.__fileLevelSelections && window.__fileLevelSelections[idx]) {
            const saved = window.__fileLevelSelections[idx];
            if (saved.type && select) select.value = saved.type;
            const colorEl = row.querySelector('.file-assignment-color');
            if (saved.color && colorEl) colorEl.value = saved.color;
            // Reflect into extractedData.fileInfo so legend/dots use persisted colour
            if (extractedData && extractedData.fileInfo && extractedData.fileInfo[idx]) {
              extractedData.fileInfo[idx].customColor = saved.color || extractedData.fileInfo[idx].customColor;
              extractedData.fileInfo[idx].contentType = saved.type || extractedData.fileInfo[idx].contentType;
            }
          }
        } catch(_) {}
      });
      
      // Wire up apply buttons and helpers
      container.querySelectorAll('.apply-file-assignment').forEach(btn => {
        btn.addEventListener('click', () => {
          const idx = parseInt(btn.dataset.fileIndex);
          const typeSel = container.querySelector(`.file-assignment-type[data-file-index="${idx}"]`);
          const colorInp = container.querySelector(`.file-assignment-color[data-file-index="${idx}"]`);
          const selectedType = typeSel ? typeSel.value : 'default';
          const color = colorInp ? colorInp.value : '#dbeafe';
          applyAssignmentsForFileIndex(idx, selectedType, color);
          // Persist to localStorage immediately
          try {
            if (!window.__fileLevelSelections) window.__fileLevelSelections = {};
            window.__fileLevelSelections[idx] = { type: selectedType, color };
            localStorage.setItem('fileLevelSelections', JSON.stringify(window.__fileLevelSelections));
          } catch(_) {}
        });
      });
      // Wire up Clear saved colors
      const clearBtn = container.querySelector('#clearFileSelectionsBtn');
      if (clearBtn) {
        clearBtn.addEventListener('click', (e) => { e.preventDefault(); clearSavedFileSelections(); });
      }
      // Change colour input to default when type changes
      container.querySelectorAll('.file-assignment-type').forEach(sel => {
        sel.addEventListener('change', () => {
          const idx = parseInt(sel.dataset.fileIndex);
          const colorInp = container.querySelector(`.file-assignment-color[data-file-index="${idx}"]`);
          const def = defaultColors[sel.value] || '#dbeafe';
          if (colorInp) colorInp.value = def;
        });
      });
      // Default colour button
      container.querySelectorAll('.use-default-color').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.preventDefault();
          const idx = parseInt(btn.dataset.fileIndex);
          const typeSel = container.querySelector(`.file-assignment-type[data-file-index="${idx}"]`);
          const colorInp = container.querySelector(`.file-assignment-color[data-file-index="${idx}"]`);
          const def = defaultColors[typeSel ? typeSel.value : 'default'] || '#dbeafe';
          if (colorInp) colorInp.value = def;
        });
      });

      // Persist colour changes immediately when user adjusts the picker (no need to click Apply)
      container.querySelectorAll('.file-assignment-color').forEach(inp => {
        const persistColor = () => {
          try {
            const idx = parseInt(inp.dataset.fileIndex);
            const color = String(inp.value || '').trim();
            if (!color) return;
            // Save to working selections and localStorage
            if (!window.__fileLevelSelections) window.__fileLevelSelections = {};
            const prev = window.__fileLevelSelections[idx] || {};
            const typeSel = container.querySelector(`.file-assignment-type[data-file-index="${idx}"]`);
            const selType = typeSel ? String(typeSel.value || '').toLowerCase() : (prev.type || 'default');
            window.__fileLevelSelections[idx] = { type: selType, color };
            try { localStorage.setItem('fileLevelSelections', JSON.stringify(window.__fileLevelSelections)); } catch(_) {}
            // Reflect into fileInfo so legend/dots and inline colouring pick it up
            try {
              if (Array.isArray(window.fileInfo) && window.fileInfo[idx]) {
                window.fileInfo[idx].customColor = color;
                // do not modify contentType here
              }
              if (extractedData && Array.isArray(extractedData.fileInfo) && extractedData.fileInfo[idx]) {
                extractedData.fileInfo[idx].customColor = color;
              }
              // Update dots for this file index
              document.querySelectorAll(`.file-accent-dot[data-file-idx="${idx}"]`).forEach(dot => { dot.style.background = color; });
            } catch(_) {}
            // Re-render headers to ensure inline custom colour is applied
            try { renderTable(); } catch(_) {}
          } catch(_) {}
        };
        inp.addEventListener('input', persistColor);
        inp.addEventListener('change', persistColor);
      });
    }

    // Apply assignments for all headers belonging to a given file index
    function applyAssignmentsForFileIndex(fileIdx, sectionKey, color) {
      try {
        if (!extractedData || !extractedData.headerFileMap) return;
        const map = extractedData.headerFileMap;
        const affected = Object.keys(map).filter(h => map[h] === fileIdx);
        affected.forEach(h => {
          headerAssignments[h] = sectionKey;
          updateHeaderCardVisual(h, sectionKey, color);
        });
        // Extend headerFileMap with typed and synonym variants for robust lookups
        try {
          const normType = (sectionKey === 'employer') ? 'employment' : sectionKey;
          const addKey = (k) => { if (k && map[k] === undefined) map[k] = fileIdx; };
          affected.forEach(h => {
            const base = String(h).replace(/\s*\[[^\]]+\]\s*$/, '').replace(/\s*\([^)]*\)\s*$/, '').trim();
            // Try to recover label text from original key if present
            const labelMatch = String(h).match(/\[([^\]]+)\]\s*$/);
            const label = labelMatch && labelMatch[1] ? labelMatch[1] : null;
            const typed = `${base} (${normType})`;
            const empEng = `${base} (Employer Engagement)`;
            const empAct = `${base} (Employer Activity)`;
            const enr = `${base} (Enrichment)`;
            [typed, empEng, empAct, enr, base].forEach(k => addKey(k));
            if (label) {
              [
                `${typed} [${label}]`,
                `${empEng} [${label}]`,
                `${empAct} [${label}]`,
                `${enr} [${label}]`,
                `${base} [${label}]`
              ].forEach(k => addKey(k));
            }
          });
        } catch(_) {}

        // Mirror the same augmentation onto the fully processed dataset so header rebuilding preserves columns
        try {
          const lpd = window.latestProcessedData;
          if (lpd && lpd.headerFileMap && typeof lpd.headerFileMap === 'object') {
            const normType2 = (sectionKey === 'employer') ? 'employment' : sectionKey;
            const addKey2 = (k) => { if (k && lpd.headerFileMap[k] === undefined) lpd.headerFileMap[k] = fileIdx; };
            // Determine headers belonging to this file within the processed dataset
            const affected2 = Object.keys(lpd.headerFileMap).filter(k => lpd.headerFileMap[k] === fileIdx);
            affected2.forEach(h => {
              const base = String(h).replace(/\s*\[[^\]]+\]\s*$/, '').replace(/\s*\([^)]*\)\s*$/, '').trim();
              const labelMatch = String(h).match(/\[([^\]]+)\]\s*$/);
              const label = labelMatch && labelMatch[1] ? labelMatch[1] : null;
              const typed = `${base} (${normType2})`;
              const empEng = `${base} (Employer Engagement)`;
              const empAct = `${base} (Employer Activity)`;
              const enr = `${base} (Enrichment)`;
              [typed, empEng, empAct, enr, base].forEach(k => addKey2(k));
              if (label) {
                [
                  `${typed} [${label}]`,
                  `${empEng} [${label}]`,
                  `${empAct} [${label}]`,
                  `${enr} [${label}]`,
                  `${base} [${label}]`
                ].forEach(k => addKey2(k));
              }
            });
          }
        } catch(_) {}
        // Persist chosen colour on extractedData.fileInfo so other UI (e.g., dots, legends) can read it
        try {
          if (extractedData && extractedData.fileInfo && extractedData.fileInfo[fileIdx]) {
            extractedData.fileInfo[fileIdx].customColor = color;
            // Also update content type immediately so activity tables render data without waiting for server
            const normType = (sectionKey === 'employer') ? 'employment' : sectionKey;
            extractedData.fileInfo[fileIdx].contentType = normType;
          }
          if (Array.isArray(window.fileInfo) && window.fileInfo[fileIdx]) {
            window.fileInfo[fileIdx].customColor = color;
            const normType = (sectionKey === 'employer') ? 'employment' : sectionKey;
            window.fileInfo[fileIdx].contentType = normType;
          }
        } catch(_) {}
        // Also update processed dataset fileInfo contentType if present
        try {
          if (window.latestProcessedData && Array.isArray(window.latestProcessedData.fileInfo) && window.latestProcessedData.fileInfo[fileIdx]) {
            const normType = (sectionKey === 'employer') ? 'employment' : sectionKey;
            window.latestProcessedData.fileInfo[fileIdx].contentType = normType;
          }
        } catch(_) {}
        // Update all accent dots for this file index
        try {
          document.querySelectorAll(`.file-accent-dot[data-file-idx="${fileIdx}"]`).forEach(dot => {
            dot.style.background = color;
          });
        } catch(_) {}
        // Store a working selection so we can send to backend later
        if (!window.__fileLevelSelections) window.__fileLevelSelections = {};
        window.__fileLevelSelections[fileIdx] = { type: sectionKey, color };
        showStatus(`Applied ${sectionKey} to ${affected.length} headers for file #${fileIdx + 1}`, 'success');
        // Refresh view safely. Only rebuild from a fully processed dataset (if available).
        try {
          window.previewingTemplateRows = false;
          if (window.latestProcessedData && Array.isArray(window.latestProcessedData.departments)) {
            adaptTableToData(window.latestProcessedData);
          } else {
            // No full data yet (header-only mode). Just refresh the legend/cards and keep existing table.
            renderTable();
          }
        } catch(e) {
          console.warn('Could not refresh table after assignment:', e?.message || e);
        }
      } catch (e) {
        console.warn('applyAssignmentsForFileIndex failed:', e?.message || e);
      }
    }

    function updateHeaderCardVisual(header, sectionKey, hexColor) {
      const headerDiv = document.querySelector(`[data-header="${header}"]`);
      if (!headerDiv) return;
      const config = sectionConfig[sectionKey] || sectionConfig.default;
      headerDiv.className = `header-item p-3 border border-gray-300 rounded-lg ${config.color} cursor-pointer transition-colors`;
      // If a custom colour is provided, apply it inline so it overrides the section class
      if (hexColor) {
        try {
          headerDiv.style.backgroundColor = hexColor;
          headerDiv.style.borderColor = hexColor;
        } catch(_) {}
      }
      const status = headerDiv.querySelector('.assignment-status');
      if (status) status.textContent = `Assigned to ${config.name}`;
    }

    // Clear saved per-file type/color selections and reset UI to defaults
    function clearSavedFileSelections() {
      try {
        localStorage.removeItem('fileLevelSelections');
        window.__fileLevelSelections = {};
      } catch(_) {}
      // Reset fileInfo customColor to a default tint so accents revert
      try {
        if (Array.isArray(window.fileInfo)) {
          window.fileInfo.forEach(fi => {
            if (fi) {
              fi.customColor = '#dbeafe';
              // do not overwrite contentType here; just clear persisted override
            }
          });
        }
      } catch(_) {}
      // Also reset any manual header assignment highlights back to unassigned state
      try { resetAllHeaderAssignments(); } catch(_) {}
      // Rebuild assignments UI (which will now show defaults)
      try { buildFileAssignmentsUI(); } catch(_) {}
      // Rebuild legend from fileInfo
      try {
        const legend = document.getElementById('fileLegend');
        if (legend && Array.isArray(window.fileInfo)) {
          legend.innerHTML = window.fileInfo.map((fi, idx) => {
            const c = (fi && fi.customColor) ? fi.customColor : ['#1d4ed8', '#9333ea', '#059669', '#ea580c', '#dc2626', '#0ea5e9', '#f59e0b'][idx % 7];
            const name = (fi && (fi.originalName || fi.filename)) ? (fi.originalName || fi.filename) : `File ${idx + 1}`;
            return `<span style="display:inline-flex;align-items:center;margin-right:12px;margin-bottom:6px;"><span style="display:inline-block;width:10px;height:10px;background:${c};border-radius:2px;margin-right:6px;"></span>${name}</span>`;
          }).join('');
        }
      } catch(_) {}
      // Finally re-render the table so header accents reflect defaults
      try { renderTable(); } catch(_) {}
      showStatus('Cleared saved colors. Defaults restored.', 'success');
    }

    // Collect file-level selections to send with manual assignment request
    function getFileLevelSelectionsFromUI() {
      const selections = {};
      const container = document.getElementById('fileAssignments');
      if (!container) return selections;
      container.querySelectorAll('.file-assignment-type').forEach(sel => {
        const idx = parseInt(sel.dataset.fileIndex);
        const color = (container.querySelector(`.file-assignment-color[data-file-index="${idx}"]`) || {}).value || '#dbeafe';
        selections[idx] = { type: sel.value, color };
      });
      // Prefer applied selections (Apply button) if present
      if (window.__fileLevelSelections) {
        Object.keys(window.__fileLevelSelections).forEach(k => {
          selections[k] = window.__fileLevelSelections[k];
        });
      }
      return selections;
    }
    
    function showSectionAssignmentModal(header) {
      const modal = document.createElement('div');
      modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
      modal.innerHTML = `
        <div class="bg-white rounded-lg p-6 max-w-md w-full mx-4">
          <h3 class="text-lg font-semibold mb-4">Assign "${stripFileLabel(header)}" to Section</h3>
          <div class="space-y-2 mb-6">
            ${Object.entries(sectionConfig).map(([key, config]) => `
              <button class="section-option w-full text-left p-3 border rounded-lg hover:bg-gray-50 transition-colors"
                      data-section="${key}">
                <div class="flex items-center gap-3">
                  <div class="w-4 h-4 ${config.color} rounded"></div>
                  <span class="font-medium">${config.name}</span>
                </div>
              </button>
            `).join('')}
          </div>
          <div class="flex gap-2">
            <button class="cancel-assignment bg-gray-500 text-white px-4 py-2 rounded hover:bg-gray-600">Cancel</button>
            <button class="unassign-header bg-red-500 text-white px-4 py-2 rounded hover:bg-red-600">Unassign</button>
          </div>
        </div>
      `;
      
      // Add event listeners
      modal.querySelectorAll('.section-option').forEach(btn => {
        btn.addEventListener('click', () => {
          const section = btn.dataset.section;
          assignHeaderToSection(header, section);
          document.body.removeChild(modal);
        });
      });
      
      modal.querySelector('.cancel-assignment').addEventListener('click', () => {
        document.body.removeChild(modal);
      });
      
      modal.querySelector('.unassign-header').addEventListener('click', () => {
        unassignHeader(header);
        document.body.removeChild(modal);
      });
      
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          document.body.removeChild(modal);
        }
      });
      
      document.body.appendChild(modal);
    }
    
    function assignHeaderToSection(header, section) {
      headerAssignments[header] = section;
      
      // Update visual display
      const headerDiv = document.querySelector(`[data-header="${header}"]`);
      if (headerDiv) {
        const config = sectionConfig[section];
        headerDiv.className = `header-item p-3 border border-gray-300 rounded-lg ${config.color} cursor-pointer transition-colors`;
        headerDiv.querySelector('.assignment-status').textContent = `Assigned to ${config.name}`;
      }
      
      console.log('Header assignment updated:', headerAssignments);
    }
    
    function unassignHeader(header) {
      delete headerAssignments[header];
      
      // Update visual display
      const headerDiv = document.querySelector(`[data-header="${header}"]`);
      if (headerDiv) {
        headerDiv.className = 'header-item p-3 border border-gray-300 rounded-lg cursor-pointer hover:bg-gray-50 transition-colors';
        headerDiv.querySelector('.assignment-status').textContent = 'Click to assign';
      }
      
      console.log('Header unassigned, current assignments:', headerAssignments);
    }
    
    function resetAllHeaderAssignments() {
      headerAssignments = {};
      
      // Reset all visual displays
      document.querySelectorAll('.header-item').forEach(headerDiv => {
        headerDiv.className = 'header-item p-3 border border-gray-300 rounded-lg cursor-pointer hover:bg-gray-50 transition-colors';
        headerDiv.querySelector('.assignment-status').textContent = 'Click to assign';
      });
      
      console.log('All header assignments reset');
    }
    
    async function applyHeaderAssignmentsAndGenerate() {
      if (!extractedData) {
        showStatus('No data available. Please upload files first.', 'error');
        return;
      }
      
      console.log('Applying header assignments:', headerAssignments);
      
      // Create a modified version of the data with assignments
      const formData = new FormData();
      const fileInput = document.getElementById('fileInput');
      
      const orderedFiles3 = getOrderedFiles();
      for (const file of orderedFiles3) {
        formData.append('files', file);
      }
      
      // Build normalised header assignments:
      // - Keys must be the raw headers as they appear in the sheet (no [Label], no (Type) suffix)
      // - Do NOT propagate per-file dropdown selections to all headers.
      //   Per-file types will still be sent separately via fileTypes and respected by the backend.
      try {
        const normalised = {};
        const baseOf = (h) => String(h || '')
          .replace(/\s*\[[^\]]+\]\s*$/, '')
          .replace(/\s*\([^)]*\)\s*$/, '')
          .trim();
        // 1) Normalise any manual per-header assignments the user explicitly made by clicking header cards
        Object.keys(headerAssignments || {}).forEach(k => {
          const base = baseOf(k);
          if (base) normalised[base] = headerAssignments[k];
        });
        console.log('Normalised header assignments to send:', normalised);
        formData.append('headerAssignments', JSON.stringify(normalised));
      } catch (e) {
        console.warn('Failed to normalise header assignments, sending raw:', e?.message || e);
        formData.append('headerAssignments', JSON.stringify(headerAssignments || {}));
      }
      // Include file-level selections (section + color per file) for backend coloring/ordering
      try {
        const fileSelections = getFileLevelSelectionsFromUI();
        formData.append('fileTypes', JSON.stringify(fileSelections));
        console.log('Included file-level selections:', fileSelections);
      } catch (e) {
        console.warn('Could not include file-level selections:', e?.message || e);
      }
      formData.append('useManualAssignment', 'true');
      
      showStatus('Generating report with header assignments...', 'info');
      
      try {
        const response = await axios.post('/api/upload', formData);
        console.log('Manual assignment response:', response.data);
        
        if (response.data.success) {
          console.log('Processing successful, adapting table to data...');
          const processed = response.data.data || response.data;
          await adaptTableToData(processed);
          showStatus('Report generated successfully with manual assignments!', 'success');
          // Hide the assignment interface
          document.getElementById('headerAssignmentSection').classList.add('hidden');
        } else {
          throw new Error(response.data.error || 'Processing failed');
        }
      } catch (error) {
        console.error('Processing error:', error);
        showStatus(`Processing failed: ${error.message}`, 'error');
      }
    }
    
    function applyHeaderColoringFromAssignments(headers) {
      tableHeaderColors = headers.map(header => {
        const assignment = headerAssignments[header];
        if (assignment && sectionConfig[assignment]) {
          return sectionConfig[assignment].color.replace('bg-', '').replace('-200', '').replace('-100', '');
        }
        return 'gray';
      });
      
      console.log('Applied header colors based on assignments:', tableHeaderColors);
    }

    // Call initialization when page loads
    document.addEventListener('DOMContentLoaded', function() {
      // Initialize editing after a short delay to ensure table is rendered
      setTimeout(initializeEditing, 1000);
      
      
      const applyAssignmentsBtn = document.getElementById('applyHeaderAssignments');
      if (applyAssignmentsBtn) {
        applyAssignmentsBtn.addEventListener('click', applyHeaderAssignmentsAndGenerate);
      }
      
      const resetAssignmentsBtn = document.getElementById('resetHeaderAssignments');
      if (resetAssignmentsBtn) {
        resetAssignmentsBtn.addEventListener('click', resetAllHeaderAssignments);
      }
      
      // Final generate button
      const finalGenerateBtn = document.getElementById('finalGenerateBtn');
      if (finalGenerateBtn) {
        finalGenerateBtn.addEventListener('click', generateReport);
      }
    });
  </script>
</body>
</html> 